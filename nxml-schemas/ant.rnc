boolean = "true" | "false" | "on" | "off" | "yes" | "no"
tasks =
  p4sync
  | vsscheckin
  | ejbjar
  | p4add
  | javadoc2
  | junitreport
  | ccmkattr
  | presetdef
  | native2ascii
  | echo
  | apt
  | typedef
  | cccheckout
  | soscheckin
  | ccmkbl
  | property
  | whichresource
  | script
  | signjar
  | defaultexcludes
  | wljspc
  | propertyfile
  | hostinfo
  | ccmklabel
  | mkdir
  | p4change
  | condition
  | vsscreate
  | uptodate
  | diagnostics
  | p4have
  | jar
  | local
  | copypath
  | deltree
  | copyfile
  | cvstagdiff
  | manifestclasspath
  | untar
  | cclock
  | echoxml
  | execon
  | ant
  | get
  | antstructure
  | cvschangelog
  | jspc
  | p4label
  | subant
  | truncate
  | ccmklbtype
  | vsshistory
  | jlink
  | chown
  | makeurl
  | chgrp
  | p4integrate
  | telnet
  | war
  | jarlib-display
  | ccmkdir
  | p4labelsync
  | vssadd
  | zip
  | antcall
  | cab
  | rpm
  | classloader
  | p4counter
  | javah
  | junit
  | cccheckin
  | setproxy
  | loadresource
  | checksum
  | javac
  | p4delete
  | ear
  | jjtree
  | soslabel
  | loadfile
  | \include
  | jarlib-available
  | mimemail
  | input
  | jjdoc
  | taskdef
  | javadoc
  | depend
  | ftp
  | vssget
  | dirname
  | sleep
  | import
  | scriptdef
  | augment
  | splash
  | rmic
  | jarlib-resolve
  | macrodef
  | touch
  | apply
  | pathconvert
  | xmlproperty
  | ccunlock
  | xslt
  | blgenclient
  | jarlib-manifest
  | javacc
  | move
  | retry
  | ccmreconfigure
  | ccmcheckintask
  | bindtargets
  | waitfor
  | vsscp
  | gzip
  | filter
  | sound
  | ccrmtype
  | basename
  | antversion
  | patch
  | tar
  | p4submit
  | bzip2
  | ccupdate
  | resourcecount
  | componentdef
  | cvs
  | echoproperties
  | p4resolve
  | tstamp
  | vsslabel
  | rename
  | ccmcheckin
  | buildnumber
  | length
  | concat
  | sync
  | unjar
  | available
  | loadproperties
  | schemavalidate
  | antlr
  | vsscheckout
  | netrexxc
  | projecthelper
  | cvsversion
  | genkey
  | manifest
  | sequential
  | xmlvalidate
  | nice
  | p4edit
  | tempfile
  | sosget
  | exec
  | unwar
  | chmod
  | rexec
  | attrib
  | iplanet-ejbc
  | symlink
  | unzip
  | ccmcreatetask
  | dependset
  | sql
  | ccmkelem
  | ccuncheckout
  | fail
  | pvcs
  | translate
  | java
  | verifyjar
  | p4revert
  | mail
  | replaceregexp
  | bunzip2
  | ccmcheckout
  | record
  | cvspass
  | fixcrlf
  | replace
  | renameext
  | style
  | p4reopen
  | parallel
  | soscheckout
  | copy
  | serverdeploy
  | gunzip
  | p4fstat
  | delete
  | propertyhelper
  | copydir
types =
  cutdirsmapper
  | packagemapper
  | fileset
  | scriptfilter
  | flattenmapper
  | resources
  | concatfilter
  | classfileset
  | resourcelist
  | isfileselected
  | first
  | extension
  | linetokenizer
  | chainedmapper
  | restrict
  | signedselector
  | tarentry
  | substitution
  | propertyset
  | difference
  | file
  | mappedresources
  | url
  | zipfileset
  | propertyresource
  | scriptselector
  | regexpmapper
  | filetokenizer
  | patternset
  | filterset
  | redirector
  | union
  | intersect
  | firstmatchmapper
  | stringtokenizer
  | path
  | mapper
  | resource
  | scriptmapper
  | filelist
  | archives
  | gzipresource
  | scriptcondition
  | dirset
  | description
  | globmapper
  | filterchain
  | zipentry
  | identitymapper
  | filterreader
  | extensionSet
  | xmlcatalog
  | regexp
  | files
  | unpackagemapper
  | bzip2resource
  | javaresource
  | selector
  | sort
  | libfileset
  | assertions
  | filtermapper
  | \string
  | mergemapper
  | compositemapper
  | last
  | tokens
  | tarfileset
project =
  element project {
    attlist.project, (target | extension-point | tasks | types)*
  }
attlist.project &=
  attribute name { text }?,
  attribute default { text }?,
  attribute basedir { text }?
target = element target { attlist.target, (tasks | types)* }
attlist.target &=
  attribute id { xsd:ID }?,
  attribute name { text },
  attribute if { text }?,
  attribute unless { text }?,
  attribute depends { text }?,
  attribute extensionOf { text }?,
  attribute onMissingExtensionPoint { text }?,
  attribute description { text }?
extension-point =
  element extension-point { attlist.extension-point, empty }
attlist.extension-point &=
  attribute id { xsd:ID }?,
  attribute name { text },
  attribute if { text }?,
  attribute unless { text }?,
  attribute depends { text }?,
  attribute extensionOf { text }?,
  attribute onMissingExtensionPoint { text }?,
  attribute description { text }?
selector =
  element selector {
    attlist.selector,
    (custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | date
     | and
     | depth)*
  }
attlist.selector &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute unless { text }?,
  attribute if { text }?
custom = element custom { attlist.custom, (classpath | param)* }
attlist.custom &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute error { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute classname { text }?
classpath =
  element classpath {
    attlist.classpath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.classpath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
fileset =
  element fileset {
    attlist.fileset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.fileset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
patternset =
  element patternset {
    attlist.patternset,
    (\include
     | patternset
     | exclude
     | excludesfile
     | invert
     | includesfile)*
  }
attlist.patternset &=
  attribute id { xsd:ID }?,
  attribute includes { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute includesfile { text }?,
  attribute excludes { text }?
\include = element include { attlist.include, empty }
attlist.include &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute unless { text }?,
  attribute if { text }?
exclude = element exclude { attlist.exclude, empty }
attlist.exclude &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute unless { text }?,
  attribute if { text }?
excludesfile = element excludesfile { attlist.excludesfile, empty }
attlist.excludesfile &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute unless { text }?,
  attribute if { text }?
invert =
  element invert {
    attlist.invert,
    (\include
     | patternset
     | exclude
     | excludesfile
     | invert
     | includesfile)*
  }
attlist.invert &=
  attribute id { xsd:ID }?,
  attribute includes { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute includesfile { text }?,
  attribute excludes { text }?
includesfile = element includesfile { attlist.includesfile, empty }
attlist.includesfile &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute unless { text }?,
  attribute if { text }?
none =
  element none {
    attlist.none,
    (custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | date
     | and
     | depth)*
  }
attlist.none &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
present = element present { attlist.present, mapper* }
attlist.present &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute targetdir { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute present { "srconly" | "both" }?
mapper = element mapper { attlist.mapper, (classpath | mapper)* }
attlist.mapper &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute type {
    "identity"
    | "flatten"
    | "glob"
    | "merge"
    | "regexp"
    | "package"
    | "unpackage"
  }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute classname { text }?,
  attribute to { text }?,
  attribute from { text }?
not =
  element not {
    attlist.not,
    (custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | date
     | and
     | depth)*
  }
attlist.not &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
type = element type { attlist.type, empty }
attlist.type &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute refid { xsd:IDREF }?,
  attribute type { "file" | "dir" }?,
  attribute description { text }?
readable = element readable { attlist.readable, empty }
attlist.readable &= attribute id { xsd:ID }?
writable = element writable { attlist.writable, empty }
attlist.writable &= attribute id { xsd:ID }?
modified = element modified { attlist.modified, (classpath | param)* }
attlist.modified &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute cache { "propertyfile" }?,
  attribute comparator { "equal" | "rule" }?,
  attribute update { boolean }?,
  attribute algorithmclass { text }?,
  attribute algorithm { "hashvalue" | "digest" | "checksum" }?,
  attribute error { text }?,
  attribute delayupdate { boolean }?,
  attribute cacheclass { text }?,
  attribute description { text }?,
  attribute comparatorclass { text }?,
  attribute modified { text }?,
  attribute selres { boolean }?,
  attribute seldirs { boolean }?
param = element param { attlist.param, empty }
attlist.param &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute type { text }?,
  attribute value { text }?
or =
  element or {
    attlist.or,
    (custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | date
     | and
     | depth)*
  }
attlist.or &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
contains = element contains { attlist.contains, empty }
attlist.contains &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute casesensitive { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute text { text }?,
  attribute ignorewhitespace { boolean }?
depend = element depend { attlist.depend, mapper* }
attlist.depend &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute targetdir { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute granularity { text }?
different = element different { attlist.different, mapper* }
attlist.different &=
  attribute id { xsd:ID }?,
  attribute ignorecontents { boolean }?,
  attribute error { text }?,
  attribute targetdir { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute ignorefiletimes { boolean }?,
  attribute granularity { text }?
size = element size { attlist.size, empty }
attlist.size &=
  attribute id { xsd:ID }?,
  attribute when {
    "equal"
    | "greater"
    | "less"
    | "ne"
    | "ge"
    | "le"
    | "eq"
    | "gt"
    | "lt"
    | "more"
  }?,
  attribute units {
    "K"
    | "k"
    | "kilo"
    | "KILO"
    | "Ki"
    | "KI"
    | "ki"
    | "kibi"
    | "KIBI"
    | "M"
    | "m"
    | "mega"
    | "MEGA"
    | "Mi"
    | "MI"
    | "mi"
    | "mebi"
    | "MEBI"
    | "G"
    | "g"
    | "giga"
    | "GIGA"
    | "Gi"
    | "GI"
    | "gi"
    | "gibi"
    | "GIBI"
    | "T"
    | "t"
    | "tera"
    | "TERA"
    | "Ti"
    | "TI"
    | "ti"
    | "tebi"
    | "TEBI"
  }?,
  attribute error { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute value { text }?
majority =
  element majority {
    attlist.majority,
    (custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | date
     | and
     | depth)*
  }
attlist.majority &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute refid { xsd:IDREF }?,
  attribute allowtie { boolean }?,
  attribute description { text }?
containsregexp =
  element containsregexp { attlist.containsregexp, empty }
attlist.containsregexp &=
  attribute id { xsd:ID }?,
  attribute multiline { boolean }?,
  attribute error { text }?,
  attribute singleline { boolean }?,
  attribute casesensitive { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute expression { text }?
filename = element filename { attlist.filename, empty }
attlist.filename &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute name { text }?,
  attribute casesensitive { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute regex { text }?,
  attribute negate { boolean }?
date = element date { attlist.date, empty }
attlist.date &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute millis { text }?,
  attribute checkdirs { boolean }?,
  attribute datetime { text }?,
  attribute granularity { text }?,
  attribute pattern { text }?,
  attribute when { "before" | "after" | "equal" }?,
  attribute error { text }?,
  attribute description { text }?
and =
  element and {
    attlist.and,
    (custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | date
     | and
     | depth)*
  }
attlist.and &=
  attribute id { xsd:ID }?,
  attribute error { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
depth = element depth { attlist.depth, empty }
attlist.depth &=
  attribute id { xsd:ID }?,
  attribute max { text }?,
  attribute error { text }?,
  attribute min { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
dirset =
  element dirset {
    attlist.dirset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.dirset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
extdirs =
  element extdirs {
    attlist.extdirs,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.extdirs &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
existing =
  element existing {
    attlist.existing,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.existing &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
filelist = element filelist { attlist.filelist, file* }
attlist.filelist &=
  attribute id { xsd:ID }?,
  attribute dir { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute files { text }?
file = element file { attlist.file, empty }
attlist.file &=
  attribute id { xsd:ID }?,
  attribute name { text }?
pathelement = element pathelement { attlist.pathelement, empty }
attlist.pathelement &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute path { text }?
path =
  element path {
    attlist.path,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.path &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
resources = element resources { attlist.resources, empty }
attlist.resources &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
firstmatchmapper =
  element firstmatchmapper { attlist.firstmatchmapper, mapper* }
attlist.firstmatchmapper &=
  attribute id { xsd:ID }?,
  attribute to { text }?,
  attribute from { text }?
packagemapper = element packagemapper { attlist.packagemapper, empty }
attlist.packagemapper &=
  attribute id { xsd:ID }?,
  attribute handledirsep { boolean }?,
  attribute casesensitive { boolean }?,
  attribute to { text }?,
  attribute from { text }?
last = element last { attlist.last, empty }
attlist.last &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute count { text }?
javaresource = element javaresource { attlist.javaresource, classpath* }
attlist.javaresource &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute name { text }?,
  attribute classpath { text }?,
  attribute lastmodified { text }?,
  attribute parentfirst { boolean }?,
  attribute directory { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute loaderref { xsd:IDREF }?,
  attribute exists { boolean }?,
  attribute description { text }?,
  attribute size { text }?
substitution = element substitution { attlist.substitution, empty }
attlist.substitution &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute expression { text }?
filterset =
  element filterset {
    attlist.filterset, (filterset | filter | filtersfile)*
  }
attlist.filterset &=
  attribute id { xsd:ID }?,
  attribute begintoken { text }?,
  attribute onmissingfiltersfile { "fail" | "warn" | "ignore" }?,
  attribute endtoken { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute recurse { boolean }?,
  attribute filtersfile { text }?
filter = element filter { attlist.filter, empty }
attlist.filter &=
  attribute id { xsd:ID }?,
  attribute token { text }?,
  attribute value { text }?
filtersfile = element filtersfile { attlist.filtersfile, empty }
attlist.filtersfile &=
  attribute id { xsd:ID }?,
  attribute file { text }?
libfileset =
  element libfileset {
    attlist.libfileset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.libfileset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute urlbase { text }?,
  attribute file { text }?,
  attribute includeimpl { boolean }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute includeurl { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute includesfile { text }?,
  attribute excludes { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
gzipresource = element gzipresource { attlist.gzipresource, empty }
attlist.gzipresource &=
  attribute id { xsd:ID }?,
  attribute directory { boolean }?,
  attribute name { text }?,
  attribute lastmodified { text }?,
  attribute size { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute exists { boolean }?
assertions =
  element assertions { attlist.assertions, (disable | enable)* }
attlist.assertions &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute enablesystemassertions { boolean }?
disable = element disable { attlist.disable, empty }
attlist.disable &=
  attribute id { xsd:ID }?,
  attribute package { text }?,
  attribute class { text }?
enable = element enable { attlist.enable, empty }
attlist.enable &=
  attribute id { xsd:ID }?,
  attribute package { text }?,
  attribute class { text }?
filterchain =
  element filterchain {
    attlist.filterchain,
    (headfilter
     | classconstants
     | linecontains
     | filterreader
     | replaceregex
     | suffixlines
     | replacetokens
     | escapeunicode
     | ignoreblank
     | tailfilter
     | tabstospaces
     | prefixlines
     | trim
     | expandproperties
     | striplinebreaks
     | replacestring
     | striplinecomments
     | tokenfilter
     | stripjavacomments
     | containsregex
     | deletecharacters
     | linecontainsregexp)*
  }
attlist.filterchain &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
headfilter = element headfilter { attlist.headfilter, empty }
attlist.headfilter &=
  attribute id { xsd:ID }?,
  attribute lines { text }?,
  attribute skip { text }?
classconstants =
  element classconstants { attlist.classconstants, empty }
attlist.classconstants &= attribute id { xsd:ID }?
linecontains = element linecontains { attlist.linecontains, contains* }
attlist.linecontains &=
  attribute id { xsd:ID }?,
  attribute negate { boolean }?
filterreader =
  element filterreader { attlist.filterreader, (classpath | param)* }
attlist.filterreader &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute classname { text }?
replaceregex = element replaceregex { attlist.replaceregex, empty }
attlist.replaceregex &=
  attribute id { xsd:ID }?,
  attribute flags { text }?,
  attribute byline { boolean }?,
  attribute replace { text }?,
  attribute description { text }?,
  attribute pattern { text }?
suffixlines = element suffixlines { attlist.suffixlines, empty }
attlist.suffixlines &=
  attribute id { xsd:ID }?,
  attribute suffix { text }?
replacetokens = element replacetokens { attlist.replacetokens, \token* }
attlist.replacetokens &=
  attribute id { xsd:ID }?,
  attribute propertiesresource { text }?,
  attribute begintoken { text }?,
  attribute endtoken { text }?
\token = element token { attlist.token, empty }
attlist.token &=
  attribute id { xsd:ID }?,
  attribute key { text }?,
  attribute value { text }?
escapeunicode = element escapeunicode { attlist.escapeunicode, empty }
attlist.escapeunicode &= attribute id { xsd:ID }?
ignoreblank = element ignoreblank { attlist.ignoreblank, empty }
attlist.ignoreblank &=
  attribute id { xsd:ID }?,
  attribute byline { boolean }?,
  attribute description { text }?
tailfilter = element tailfilter { attlist.tailfilter, empty }
attlist.tailfilter &=
  attribute id { xsd:ID }?,
  attribute lines { text }?,
  attribute skip { text }?
tabstospaces = element tabstospaces { attlist.tabstospaces, empty }
attlist.tabstospaces &=
  attribute id { xsd:ID }?,
  attribute tablength { text }?
prefixlines = element prefixlines { attlist.prefixlines, empty }
attlist.prefixlines &=
  attribute id { xsd:ID }?,
  attribute prefix { text }?
trim = element trim { attlist.trim, empty }
attlist.trim &=
  attribute id { xsd:ID }?,
  attribute byline { boolean }?,
  attribute description { text }?
expandproperties =
  element expandproperties { attlist.expandproperties, empty }
attlist.expandproperties &= attribute id { xsd:ID }?
striplinebreaks =
  element striplinebreaks { attlist.striplinebreaks, empty }
attlist.striplinebreaks &=
  attribute id { xsd:ID }?,
  attribute linebreaks { text }?
replacestring = element replacestring { attlist.replacestring, empty }
attlist.replacestring &=
  attribute id { xsd:ID }?,
  attribute byline { boolean }?,
  attribute description { text }?,
  attribute to { text }?,
  attribute from { text }?
striplinecomments =
  element striplinecomments { attlist.striplinecomments, comment* }
attlist.striplinecomments &= attribute id { xsd:ID }?
comment = element comment { attlist.comment, text }
attlist.comment &=
  attribute id { xsd:ID }?,
  attribute value { text }?
tokenfilter =
  element tokenfilter {
    attlist.tokenfilter,
    (containsstring
     | linetokenizer
     | trim
     | stringtokenizer
     | replaceregex
     | replacestring
     | ignoreblank
     | deletecharacters
     | containsregex
     | filetokenizer)*
  }
attlist.tokenfilter &=
  attribute id { xsd:ID }?,
  attribute delimoutput { text }?
containsstring =
  element containsstring { attlist.containsstring, empty }
attlist.containsstring &=
  attribute id { xsd:ID }?,
  attribute contains { text }?,
  attribute description { text }?
linetokenizer = element linetokenizer { attlist.linetokenizer, empty }
attlist.linetokenizer &=
  attribute id { xsd:ID }?,
  attribute includedelims { boolean }?,
  attribute description { text }?
stringtokenizer =
  element stringtokenizer { attlist.stringtokenizer, empty }
attlist.stringtokenizer &=
  attribute id { xsd:ID }?,
  attribute suppressdelims { boolean }?,
  attribute includedelims { boolean }?,
  attribute description { text }?,
  attribute delimsaretokens { boolean }?,
  attribute delims { text }?
deletecharacters =
  element deletecharacters { attlist.deletecharacters, empty }
attlist.deletecharacters &=
  attribute id { xsd:ID }?,
  attribute description { text }?,
  attribute chars { text }?
containsregex = element containsregex { attlist.containsregex, empty }
attlist.containsregex &=
  attribute id { xsd:ID }?,
  attribute flags { text }?,
  attribute byline { boolean }?,
  attribute replace { text }?,
  attribute description { text }?,
  attribute pattern { text }?
filetokenizer = element filetokenizer { attlist.filetokenizer, empty }
attlist.filetokenizer &=
  attribute id { xsd:ID }?,
  attribute description { text }?
stripjavacomments =
  element stripjavacomments { attlist.stripjavacomments, empty }
attlist.stripjavacomments &= attribute id { xsd:ID }?
linecontainsregexp =
  element linecontainsregexp { attlist.linecontainsregexp, regexp* }
attlist.linecontainsregexp &=
  attribute id { xsd:ID }?,
  attribute casesensitive { boolean }?,
  attribute negate { boolean }?
regexp = element regexp { attlist.regexp, empty }
attlist.regexp &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute pattern { text }?
description = element description { attlist.description, text }
attlist.description &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
scriptselector =
  element scriptselector { attlist.scriptselector, (text | classpath)* }
attlist.scriptselector &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute src { text }?,
  attribute classpath { text }?,
  attribute manager { text }?,
  attribute selected { boolean }?,
  attribute language { text }?,
  attribute setbeans { boolean }?,
  attribute error { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute description { text }?
flattenmapper = element flattenmapper { attlist.flattenmapper, empty }
attlist.flattenmapper &=
  attribute id { xsd:ID }?,
  attribute to { text }?,
  attribute from { text }?
zipfileset =
  element zipfileset {
    attlist.zipfileset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.zipfileset &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute encoding { text }?,
  attribute filemode { text }?,
  attribute defaultexcludes { boolean }?,
  attribute src { text }?,
  attribute srcresource { text }?,
  attribute fullpath { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute erroronmissingarchive { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute casesensitive { boolean }?,
  attribute dir { text }?,
  attribute erroronmissingdir { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute prefix { text }?,
  attribute dirmode { text }?,
  attribute includesfile { text }?,
  attribute file { text }?,
  attribute excludesfile { text }?
tokens = element tokens { attlist.tokens, empty }
attlist.tokens &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute encoding { text }?
tarentry = element tarentry { attlist.tarentry, empty }
attlist.tarentry &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute name { text }?,
  attribute archive { text }?,
  attribute lastmodified { text }?,
  attribute mode { text }?,
  attribute directory { boolean }?,
  attribute exists { boolean }?,
  attribute description { text }?,
  attribute size { text }?
scriptfilter =
  element scriptfilter { attlist.scriptfilter, (text | classpath)* }
attlist.scriptfilter &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute classpath { text }?,
  attribute token { text }?,
  attribute manager { text }?,
  attribute language { text }?,
  attribute byline { boolean }?,
  attribute setbeans { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute description { text }?
bzip2resource = element bzip2resource { attlist.bzip2resource, empty }
attlist.bzip2resource &=
  attribute id { xsd:ID }?,
  attribute directory { boolean }?,
  attribute name { text }?,
  attribute lastmodified { text }?,
  attribute size { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute exists { boolean }?
scriptcondition =
  element scriptcondition {
    attlist.scriptcondition, (text | classpath)*
  }
attlist.scriptcondition &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute manager { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute description { text }?,
  attribute value { boolean }?,
  attribute setbeans { boolean }?,
  attribute src { text }?,
  attribute language { text }?
restrict = element restrict { attlist.restrict, empty }
attlist.restrict &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
url = element url { attlist.url, empty }
attlist.url &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute url { text }?,
  attribute name { text }?,
  attribute relativepath { text }?,
  attribute file { text }?,
  attribute lastmodified { text }?,
  attribute directory { boolean }?,
  attribute baseurl { text }?,
  attribute exists { boolean }?,
  attribute description { text }?,
  attribute size { text }?
difference = element difference { attlist.difference, empty }
attlist.difference &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
filtermapper =
  element filtermapper {
    attlist.filtermapper,
    (headfilter
     | classconstants
     | linecontains
     | filterreader
     | replaceregex
     | suffixlines
     | replacetokens
     | escapeunicode
     | ignoreblank
     | tailfilter
     | tabstospaces
     | prefixlines
     | trim
     | expandproperties
     | striplinebreaks
     | replacestring
     | striplinecomments
     | tokenfilter
     | stripjavacomments
     | containsregex
     | deletecharacters
     | linecontainsregexp)*
  }
attlist.filtermapper &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute to { text }?,
  attribute from { text }?
intersect = element intersect { attlist.intersect, empty }
attlist.intersect &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
tarfileset =
  element tarfileset {
    attlist.tarfileset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.tarfileset &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute username { text }?,
  attribute filemode { text }?,
  attribute defaultexcludes { boolean }?,
  attribute src { text }?,
  attribute uid { text }?,
  attribute srcresource { text }?,
  attribute group { text }?,
  attribute fullpath { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingarchive { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute casesensitive { boolean }?,
  attribute gid { text }?,
  attribute dir { text }?,
  attribute erroronmissingdir { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute prefix { text }?,
  attribute dirmode { text }?,
  attribute includesfile { text }?,
  attribute file { text }?,
  attribute excludesfile { text }?
signedselector =
  element signedselector { attlist.signedselector, empty }
attlist.signedselector &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
zipentry = element zipentry { attlist.zipentry, empty }
attlist.zipentry &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute name { text }?,
  attribute encoding { text }?,
  attribute archive { text }?,
  attribute lastmodified { text }?,
  attribute mode { text }?,
  attribute directory { boolean }?,
  attribute exists { boolean }?,
  attribute zipfile { text }?,
  attribute description { text }?,
  attribute size { text }?
sort = element sort { attlist.sort, empty }
attlist.sort &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
archives = element archives { attlist.archives, (tars | zips)* }
attlist.archives &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
tars = element tars { attlist.tars, empty }
attlist.tars &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
zips = element zips { attlist.zips, empty }
attlist.zips &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
regexpmapper = element regexpmapper { attlist.regexpmapper, empty }
attlist.regexpmapper &=
  attribute id { xsd:ID }?,
  attribute handledirsep { boolean }?,
  attribute casesensitive { boolean }?,
  attribute to { text }?,
  attribute from { text }?
concatfilter = element concatfilter { attlist.concatfilter, empty }
attlist.concatfilter &=
  attribute id { xsd:ID }?,
  attribute append { text }?,
  attribute prepend { text }?
cutdirsmapper = element cutdirsmapper { attlist.cutdirsmapper, empty }
attlist.cutdirsmapper &=
  attribute id { xsd:ID }?,
  attribute dirs { text }?,
  attribute to { text }?,
  attribute from { text }?
globmapper = element globmapper { attlist.globmapper, empty }
attlist.globmapper &=
  attribute id { xsd:ID }?,
  attribute handledirsep { boolean }?,
  attribute casesensitive { boolean }?,
  attribute to { text }?,
  attribute from { text }?
mergemapper = element mergemapper { attlist.mergemapper, empty }
attlist.mergemapper &=
  attribute id { xsd:ID }?,
  attribute to { text }?,
  attribute from { text }?
union = element union { attlist.union, empty }
attlist.union &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
unpackagemapper =
  element unpackagemapper { attlist.unpackagemapper, empty }
attlist.unpackagemapper &=
  attribute id { xsd:ID }?,
  attribute handledirsep { boolean }?,
  attribute casesensitive { boolean }?,
  attribute to { text }?,
  attribute from { text }?
xmlcatalog =
  element xmlcatalog {
    attlist.xmlcatalog,
    (entity | classpath | catalogpath | dtd | xmlcatalog)*
  }
attlist.xmlcatalog &=
  attribute id { xsd:ID }?,
  attribute catalogpathref { xsd:IDREF }?,
  attribute classpath { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
entity = element entity { attlist.entity, empty }
attlist.entity &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute publicid { text }?,
  attribute base { text }?
catalogpath =
  element catalogpath {
    attlist.catalogpath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.catalogpath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
dtd = element dtd { attlist.dtd, empty }
attlist.dtd &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute publicid { text }?,
  attribute base { text }?
files =
  element files {
    attlist.files,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.files &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute includes { text }?
redirector =
  element redirector {
    attlist.redirector,
    (errorfilterchain
     | outputfilterchain
     | errormapper
     | inputfilterchain
     | outputmapper
     | inputmapper)*
  }
attlist.redirector &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute inputencoding { text }?,
  attribute append { boolean }?,
  attribute createemptyfiles { boolean }?,
  attribute output { text }?,
  attribute outputproperty { text }?,
  attribute error { text }?,
  attribute errorproperty { text }?,
  attribute outputencoding { text }?,
  attribute inputstring { text }?,
  attribute alwayslog { boolean }?,
  attribute loginputstring { boolean }?,
  attribute input { text }?,
  attribute description { text }?,
  attribute errorencoding { text }?,
  attribute logerror { boolean }?
errorfilterchain =
  element errorfilterchain {
    attlist.errorfilterchain,
    (headfilter
     | classconstants
     | linecontains
     | filterreader
     | replaceregex
     | suffixlines
     | replacetokens
     | escapeunicode
     | ignoreblank
     | tailfilter
     | tabstospaces
     | prefixlines
     | trim
     | expandproperties
     | striplinebreaks
     | replacestring
     | striplinecomments
     | tokenfilter
     | stripjavacomments
     | containsregex
     | deletecharacters
     | linecontainsregexp)*
  }
attlist.errorfilterchain &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
outputfilterchain =
  element outputfilterchain {
    attlist.outputfilterchain,
    (headfilter
     | classconstants
     | linecontains
     | filterreader
     | replaceregex
     | suffixlines
     | replacetokens
     | escapeunicode
     | ignoreblank
     | tailfilter
     | tabstospaces
     | prefixlines
     | trim
     | expandproperties
     | striplinebreaks
     | replacestring
     | striplinecomments
     | tokenfilter
     | stripjavacomments
     | containsregex
     | deletecharacters
     | linecontainsregexp)*
  }
attlist.outputfilterchain &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
errormapper =
  element errormapper { attlist.errormapper, (classpath | mapper)* }
attlist.errormapper &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute type {
    "identity"
    | "flatten"
    | "glob"
    | "merge"
    | "regexp"
    | "package"
    | "unpackage"
  }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute classname { text }?,
  attribute to { text }?,
  attribute from { text }?
inputfilterchain =
  element inputfilterchain {
    attlist.inputfilterchain,
    (headfilter
     | classconstants
     | linecontains
     | filterreader
     | replaceregex
     | suffixlines
     | replacetokens
     | escapeunicode
     | ignoreblank
     | tailfilter
     | tabstospaces
     | prefixlines
     | trim
     | expandproperties
     | striplinebreaks
     | replacestring
     | striplinecomments
     | tokenfilter
     | stripjavacomments
     | containsregex
     | deletecharacters
     | linecontainsregexp)*
  }
attlist.inputfilterchain &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
outputmapper =
  element outputmapper { attlist.outputmapper, (classpath | mapper)* }
attlist.outputmapper &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute type {
    "identity"
    | "flatten"
    | "glob"
    | "merge"
    | "regexp"
    | "package"
    | "unpackage"
  }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute classname { text }?,
  attribute to { text }?,
  attribute from { text }?
inputmapper =
  element inputmapper { attlist.inputmapper, (classpath | mapper)* }
attlist.inputmapper &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute type {
    "identity"
    | "flatten"
    | "glob"
    | "merge"
    | "regexp"
    | "package"
    | "unpackage"
  }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute classname { text }?,
  attribute to { text }?,
  attribute from { text }?
identitymapper =
  element identitymapper { attlist.identitymapper, empty }
attlist.identitymapper &=
  attribute id { xsd:ID }?,
  attribute to { text }?,
  attribute from { text }?
scriptmapper =
  element scriptmapper { attlist.scriptmapper, (text | classpath)* }
attlist.scriptmapper &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute classpath { text }?,
  attribute manager { text }?,
  attribute language { text }?,
  attribute setbeans { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute from { text }?,
  attribute to { text }?,
  attribute description { text }?
extensionSet =
  element extensionSet {
    attlist.extensionSet, (fileset | libfileset | extension)*
  }
attlist.extensionSet &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
extension = element extension { attlist.extension, empty }
attlist.extension &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute implementationversion { text }?,
  attribute specificationversion { text }?,
  attribute extensionname { text }?,
  attribute implementationvendorid { text }?,
  attribute specificationvendor { text }?,
  attribute implementationurl { text }?,
  attribute description { text }?,
  attribute implementationvendor { text }?
propertyresource =
  element propertyresource { attlist.propertyresource, empty }
attlist.propertyresource &=
  attribute id { xsd:ID }?,
  attribute directory { boolean }?,
  attribute name { text }?,
  attribute lastmodified { text }?,
  attribute size { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute exists { boolean }?
resource = element resource { attlist.resource, empty }
attlist.resource &=
  attribute id { xsd:ID }?,
  attribute directory { boolean }?,
  attribute name { text }?,
  attribute lastmodified { text }?,
  attribute size { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute exists { boolean }?
classfileset =
  element classfileset {
    attlist.classfileset,
    (patternset
     | exclude
     | \include
     | custom
     | rootfileset
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | root
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.classfileset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute rootclass { text }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
rootfileset =
  element rootfileset {
    attlist.rootfileset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.rootfileset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
root = element root { attlist.root, empty }
attlist.root &=
  attribute id { xsd:ID }?,
  attribute classname { text }?
isfileselected =
  element isfileselected {
    attlist.isfileselected,
    (custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | date
     | and
     | depth)*
  }
attlist.isfileselected &=
  attribute id { xsd:ID }?,
  attribute file { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute basedir { text }?
chainedmapper = element chainedmapper { attlist.chainedmapper, mapper* }
attlist.chainedmapper &=
  attribute id { xsd:ID }?,
  attribute to { text }?,
  attribute from { text }?
propertyset =
  element propertyset {
    attlist.propertyset, (propertyref | propertyset | mapper)*
  }
attlist.propertyset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute dynamic { boolean }?,
  attribute negate { boolean }?
propertyref = element propertyref { attlist.propertyref, empty }
attlist.propertyref &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute builtin { "all" | "system" | "commandline" }?,
  attribute regex { text }?,
  attribute prefix { text }?
compositemapper =
  element compositemapper { attlist.compositemapper, mapper* }
attlist.compositemapper &=
  attribute id { xsd:ID }?,
  attribute to { text }?,
  attribute from { text }?
resourcelist =
  element resourcelist { attlist.resourcelist, filterchain* }
attlist.resourcelist &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute encoding { text }?
mappedresources =
  element mappedresources { attlist.mappedresources, mapper* }
attlist.mappedresources &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute enablemultiplemappings { boolean }?
\string = element string { attlist.string, text }
attlist.string &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute name { text }?,
  attribute encoding { text }?,
  attribute lastmodified { text }?,
  attribute directory { boolean }?,
  attribute value { text }?,
  attribute exists { boolean }?,
  attribute description { text }?,
  attribute size { text }?
first = element first { attlist.first, empty }
attlist.first &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute count { text }?
setproxy = element setproxy { attlist.setproxy, empty }
attlist.setproxy &=
  attribute id { xsd:ID }?,
  attribute nonproxyhosts { text }?,
  attribute proxyhost { text }?,
  attribute socksproxyhost { text }?,
  attribute proxyport { text }?,
  attribute socksproxyport { text }?,
  attribute taskname { text }?,
  attribute proxyuser { text }?,
  attribute description { text }?,
  attribute proxypassword { text }?
nice = element nice { attlist.nice, empty }
attlist.nice &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute newpriority { text }?,
  attribute currentpriority { text }?
whichresource =
  element whichresource { attlist.whichresource, classpath* }
attlist.whichresource &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute taskname { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute description { text }?,
  attribute property { text }?,
  attribute resource { text }?,
  attribute class { text }?
augment = element augment { attlist.augment, empty }
attlist.augment &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute proxy { text }?,
  attribute description { text }?
p4add = element p4add { attlist.p4add, fileset* }
attlist.p4add &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute changelist { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?,
  attribute commandlength { text }?
jarlib-available =
  element jarlib-available {
    attlist.jarlib-available, (extensionset | extension)*
  }
attlist.jarlib-available &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute property { text }?
extensionset =
  element extensionset {
    attlist.extensionset, (fileset | libfileset | extension)*
  }
attlist.extensionset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
propertyfile = element propertyfile { attlist.propertyfile, entry* }
attlist.propertyfile &=
  attribute id { xsd:ID }?,
  attribute jdkproperties { boolean }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute comment { text }?
entry = element entry { attlist.entry, empty }
attlist.entry &=
  attribute id { xsd:ID }?,
  attribute operation { text }?,
  attribute default { text }?,
  attribute key { text }?,
  attribute type { "int" | "date" | "string" }?,
  attribute unit {
    "millisecond"
    | "second"
    | "minute"
    | "hour"
    | "day"
    | "week"
    | "month"
    | "year"
  }?,
  attribute pattern { text }?,
  attribute value { text }?
copy =
  element copy {
    attlist.copy, (filterchain | fileset | filterset | mapper)*
  }
attlist.copy &=
  attribute id { xsd:ID }?,
  attribute flatten { boolean }?,
  attribute force { boolean }?,
  attribute encoding { text }?,
  attribute tofile { text }?,
  attribute todir { text }?,
  attribute file { text }?,
  attribute verbose { boolean }?,
  attribute includeemptydirs { boolean }?,
  attribute overwrite { boolean }?,
  attribute enablemultiplemappings { boolean }?,
  attribute granularity { text }?,
  attribute outputencoding { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute preservelastmodified { boolean }?,
  attribute filtering { boolean }?
manifestclasspath =
  element manifestclasspath { attlist.manifestclasspath, classpath* }
attlist.manifestclasspath &=
  attribute id { xsd:ID }?,
  attribute jarfile { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute property { text }?,
  attribute maxparentlevels { text }?
available =
  element available { attlist.available, (classpath | filepath)* }
attlist.available &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute file { text }?,
  attribute classname { text }?,
  attribute resource { text }?,
  attribute ignoresystemclasses { boolean }?,
  attribute type { "file" | "dir" }?,
  attribute searchparents { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute value { text }?,
  attribute description { text }?,
  attribute property { text }?,
  attribute filepath { text }?
filepath =
  element filepath {
    attlist.filepath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.filepath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
echoxml = element echoxml { attlist.echoxml, text }
attlist.echoxml &=
  attribute id { xsd:ID }?,
  attribute append { boolean }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute namespacepolicy { "ignore" | "elementsOnly" | "all" }?
chgrp =
  element chgrp {
    attlist.chgrp,
    (mapper
     | srcfile
     | targetfile
     | redirector
     | env
     | filelist
     | fileset
     | dirset
     | arg)*
  }
attlist.chgrp &=
  attribute id { xsd:ID }?,
  attribute addsourcefile { boolean }?,
  attribute verbose { boolean }?,
  attribute parallel { boolean }?,
  attribute input { text }?,
  attribute executable { text }?,
  attribute force { boolean }?,
  attribute inputstring { text }?,
  attribute osfamily { text }?,
  attribute searchpath { boolean }?,
  attribute relative { boolean }?,
  attribute skipemptyfilesets { boolean }?,
  attribute command { text }?,
  attribute forwardslash { boolean }?,
  attribute spawn { boolean }?,
  attribute description { text }?,
  attribute vmlauncher { boolean }?,
  attribute group { text }?,
  attribute file { text }?,
  attribute logerror { boolean }?,
  attribute errorproperty { text }?,
  attribute failonerror { boolean }?,
  attribute output { text }?,
  attribute error { text }?,
  attribute os { text }?,
  attribute dest { text }?,
  attribute resolveexecutable { boolean }?,
  attribute taskname { text }?,
  attribute resultproperty { text }?,
  attribute ignoremissing { boolean }?,
  attribute failifexecutionfails { boolean }?,
  attribute append { boolean }?,
  attribute timeout { text }?,
  attribute maxparallel { text }?,
  attribute outputproperty { text }?,
  attribute dir { text }?,
  attribute newenvironment { boolean }?,
  attribute type { "file" | "dir" | "both" }?
srcfile = element srcfile { attlist.srcfile, empty }
attlist.srcfile &=
  attribute id { xsd:ID }?,
  attribute prefix { text }?,
  attribute suffix { text }?
targetfile = element targetfile { attlist.targetfile, empty }
attlist.targetfile &=
  attribute id { xsd:ID }?,
  attribute prefix { text }?,
  attribute suffix { text }?
env = element env { attlist.env, empty }
attlist.env &=
  attribute id { xsd:ID }?,
  attribute key { text }?,
  attribute file { text }?,
  attribute value { text }?,
  attribute path { text }?
arg = element arg { attlist.arg, empty }
attlist.arg &=
  attribute id { xsd:ID }?,
  attribute line { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute pathref { xsd:IDREF }?,
  attribute prefix { text }?,
  attribute value { text }?,
  attribute suffix { text }?,
  attribute path { text }?
sleep = element sleep { attlist.sleep, empty }
attlist.sleep &=
  attribute id { xsd:ID }?,
  attribute hours { text }?,
  attribute taskname { text }?,
  attribute milliseconds { text }?,
  attribute minutes { text }?,
  attribute description { text }?,
  attribute seconds { text }?,
  attribute failonerror { boolean }?
ccmcheckin = element ccmcheckin { attlist.ccmcheckin, fileset* }
attlist.ccmcheckin &=
  attribute id { xsd:ID }?,
  attribute ccmaction { text }?,
  attribute task { text }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute ccmdir { text }?,
  attribute comment { text }?
p4counter = element p4counter { attlist.p4counter, empty }
attlist.p4counter &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute value { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute property { text }?,
  attribute errormessage { text }?
verifyjar =
  element verifyjar {
    attlist.verifyjar, (fileset | sysproperty | path)*
  }
attlist.verifyjar &=
  attribute id { xsd:ID }?,
  attribute storepass { text }?,
  attribute certificates { boolean }?,
  attribute keypass { text }?,
  attribute jar { text }?,
  attribute verbose { boolean }?,
  attribute maxmemory { text }?,
  attribute alias { text }?,
  attribute keystore { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute executable { text }?,
  attribute storetype { text }?
sysproperty = element sysproperty { attlist.sysproperty, empty }
attlist.sysproperty &=
  attribute id { xsd:ID }?,
  attribute key { text }?,
  attribute file { text }?,
  attribute value { text }?,
  attribute path { text }?
touch = element touch { attlist.touch, (fileset | filelist | mapper)* }
attlist.touch &=
  attribute id { xsd:ID }?,
  attribute verbose { boolean }?,
  attribute taskname { text }?,
  attribute millis { text }?,
  attribute file { text }?,
  attribute mkdirs { boolean }?,
  attribute description { text }?,
  attribute pattern { text }?,
  attribute datetime { text }?
ear =
  element ear {
    attlist.ear,
    (patternset
     | exclude
     | \include
     | custom
     | present
     | none
     | not
     | manifest
     | type
     | metainf
     | modified
     | or
     | contains
     | depend
     | fileset
     | different
     | size
     | majority
     | containsregexp
     | archives
     | indexjars
     | filename
     | selector
     | includesfile
     | zipgroupfileset
     | zipfileset
     | date
     | excludesfile
     | depth
     | and
     | service)*
  }
attlist.ear &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute manifestencoding { text }?,
  attribute destfile { text }?,
  attribute indexmetainf { boolean }?,
  attribute level { text }?,
  attribute zipfile { text }?,
  attribute basedir { text }?,
  attribute manifest { text }?,
  attribute description { text }?,
  attribute includes { text }?,
  attribute keepcompression { boolean }?,
  attribute file { text }?,
  attribute whenmanifestonly { "fail" | "skip" | "create" }?,
  attribute earfile { text }?,
  attribute duplicate { "add" | "preserve" | "fail" }?,
  attribute followsymlinks { boolean }?,
  attribute casesensitive { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute jarfile { text }?,
  attribute uselanguageencodingflag { boolean }?,
  attribute createunicodeextrafields {
    "never" | "always" | "not-encodeable"
  }?,
  attribute flattenattributes { boolean }?,
  attribute index { boolean }?,
  attribute includesfile { text }?,
  attribute update { boolean }?,
  attribute comment { text }?,
  attribute fallbacktoutf8 { boolean }?,
  attribute taskname { text }?,
  attribute strict { "fail" | "warn" | "ignore" }?,
  attribute roundup { boolean }?,
  attribute appxml { text }?,
  attribute encoding { text }?,
  attribute excludesfile { text }?,
  attribute whenempty { "fail" | "skip" | "create" }?,
  attribute filesonly { boolean }?,
  attribute filesetmanifest { "skip" | "merge" | "mergewithoutmain" }?,
  attribute mergeclasspathattributes { boolean }?,
  attribute compress { boolean }?,
  attribute preserve0permissions { boolean }?
manifest =
  element manifest { attlist.manifest, (\attribute | section)* }
attlist.manifest &= attribute id { xsd:ID }?
\attribute = element attribute { attlist.attribute, empty }
attlist.attribute &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute value { text }?
section = element section { attlist.section, \attribute* }
attlist.section &=
  attribute id { xsd:ID }?,
  attribute name { text }?
metainf =
  element metainf {
    attlist.metainf,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.metainf &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute encoding { text }?,
  attribute filemode { text }?,
  attribute defaultexcludes { boolean }?,
  attribute src { text }?,
  attribute srcresource { text }?,
  attribute fullpath { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute erroronmissingarchive { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute casesensitive { boolean }?,
  attribute dir { text }?,
  attribute erroronmissingdir { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute prefix { text }?,
  attribute dirmode { text }?,
  attribute includesfile { text }?,
  attribute file { text }?,
  attribute excludesfile { text }?
indexjars =
  element indexjars {
    attlist.indexjars,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.indexjars &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
zipgroupfileset =
  element zipgroupfileset {
    attlist.zipgroupfileset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.zipgroupfileset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
service = element service { attlist.service, provider* }
attlist.service &=
  attribute id { xsd:ID }?,
  attribute type { text }?,
  attribute description { text }?,
  attribute provider { text }?
provider = element provider { attlist.provider, empty }
attlist.provider &=
  attribute id { xsd:ID }?,
  attribute description { text }?,
  attribute classname { text }?
javadoc2 =
  element javadoc2 {
    attlist.javadoc2,
    (taglet
     | doclet
     | package
     | arg
     | link
     | doctitle
     | bottom
     | group
     | packageset
     | fileset
     | classpath
     | sourcepath
     | footer
     | source
     | bootclasspath
     | header
     | excludepackage
     | sourcefiles
     | tag)*
  }
attlist.javadoc2 &=
  attribute id { xsd:ID }?,
  attribute bottom { text }?,
  attribute verbose { boolean }?,
  attribute bootclasspathref { xsd:IDREF }?,
  attribute executable { text }?,
  attribute header { text }?,
  attribute docfilessubdirs { boolean }?,
  attribute link { text }?,
  attribute noindex { boolean }?,
  attribute access { "protected" | "public" | "package" | "private" }?,
  attribute doclet { text }?,
  attribute noqualifier { text }?,
  attribute public { boolean }?,
  attribute author { boolean }?,
  attribute footer { text }?,
  attribute docletpath { text }?,
  attribute package { boolean }?,
  attribute useexternalfile { boolean }?,
  attribute description { text }?,
  attribute sourcepathref { xsd:IDREF }?,
  attribute protected { boolean }?,
  attribute breakiterator { boolean }?,
  attribute nonavbar { boolean }?,
  attribute maxmemory { text }?,
  attribute group { text }?,
  attribute source { text }?,
  attribute linkoffline { text }?,
  attribute additionalparam { text }?,
  attribute locale { text }?,
  attribute linksource { boolean }?,
  attribute failonerror { boolean }?,
  attribute destdir { text }?,
  attribute classpath { text }?,
  attribute defaultexcludes { boolean }?,
  attribute includenosourcepackages { boolean }?,
  attribute bootclasspath { text }?,
  attribute private { boolean }?,
  attribute taskname { text }?,
  attribute charset { text }?,
  attribute nodeprecatedlist { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute stylesheetfile { text }?,
  attribute docencoding { text }?,
  attribute excludepackagenames { text }?,
  attribute docletpathref { xsd:IDREF }?,
  attribute packagenames { text }?,
  attribute windowtitle { text }?,
  attribute notree { boolean }?,
  attribute splitindex { boolean }?,
  attribute encoding { text }?,
  attribute packagelist { text }?,
  attribute doctitle { text }?,
  attribute serialwarn { boolean }?,
  attribute old { boolean }?,
  attribute use { boolean }?,
  attribute sourcepath { text }?,
  attribute helpfile { text }?,
  attribute version { boolean }?,
  attribute sourcefiles { text }?,
  attribute extdirs { text }?,
  attribute excludedocfilessubdir { text }?,
  attribute nohelp { boolean }?,
  attribute nodeprecated { boolean }?,
  attribute overview { text }?
taglet = element taglet { attlist.taglet, path* }
attlist.taglet &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute description { text }?,
  attribute pathref { xsd:IDREF }?,
  attribute path { text }?
doclet = element doclet { attlist.doclet, (path | param)* }
attlist.doclet &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute description { text }?,
  attribute pathref { xsd:IDREF }?,
  attribute path { text }?
package = element package { attlist.package, empty }
attlist.package &=
  attribute id { xsd:ID }?,
  attribute name { text }?
link = element link { attlist.link, empty }
attlist.link &=
  attribute id { xsd:ID }?,
  attribute packagelisturl { text }?,
  attribute href { text }?,
  attribute offline { boolean }?,
  attribute packagelistloc { text }?,
  attribute resolvelink { boolean }?
doctitle = element doctitle { attlist.doctitle, text }
attlist.doctitle &= attribute id { xsd:ID }?
bottom = element bottom { attlist.bottom, text }
attlist.bottom &= attribute id { xsd:ID }?
group = element group { attlist.group, (package | title)* }
attlist.group &=
  attribute id { xsd:ID }?,
  attribute packages { text }?,
  attribute title { text }?
title = element title { attlist.title, text }
attlist.title &= attribute id { xsd:ID }?
packageset =
  element packageset {
    attlist.packageset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.packageset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
sourcepath =
  element sourcepath {
    attlist.sourcepath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.sourcepath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
footer = element footer { attlist.footer, text }
attlist.footer &= attribute id { xsd:ID }?
source = element source { attlist.source, empty }
attlist.source &=
  attribute id { xsd:ID }?,
  attribute file { text }?
bootclasspath =
  element bootclasspath {
    attlist.bootclasspath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.bootclasspath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
header = element header { attlist.header, text }
attlist.header &= attribute id { xsd:ID }?
excludepackage =
  element excludepackage { attlist.excludepackage, empty }
attlist.excludepackage &=
  attribute id { xsd:ID }?,
  attribute name { text }?
sourcefiles = element sourcefiles { attlist.sourcefiles, empty }
attlist.sourcefiles &= attribute id { xsd:ID }?
tag =
  element tag {
    attlist.tag,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.tag &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute name { text }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute enabled { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute includesfile { text }?,
  attribute excludes { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute scope { text }?,
  attribute includes { text }?
p4integrate = element p4integrate { attlist.p4integrate, empty }
attlist.p4integrate &=
  attribute id { xsd:ID }?,
  attribute branch { text }?,
  attribute leavetargetrevision { boolean }?,
  attribute errormessage { text }?,
  attribute forceintegrate { boolean }?,
  attribute client { text }?,
  attribute enablebaselessmerges { boolean }?,
  attribute fromfile { text }?,
  attribute reversebranchmappings { boolean }?,
  attribute port { text }?,
  attribute change { text }?,
  attribute simulationmode { boolean }?,
  attribute propagatesourcefiletype { boolean }?,
  attribute view { text }?,
  attribute nocopynewtargetfiles { boolean }?,
  attribute tofile { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute taskname { text }?,
  attribute restoredeletedrevisions { boolean }?,
  attribute inerror { boolean }?,
  attribute user { text }?
projecthelper = element projecthelper { attlist.projecthelper, empty }
attlist.projecthelper &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?
cvstagdiff =
  element cvstagdiff { attlist.cvstagdiff, (module | commandline)* }
attlist.cvstagdiff &=
  attribute id { xsd:ID }?,
  attribute cvsrsh { text }?,
  attribute endtag { text }?,
  attribute quiet { boolean }?,
  attribute passfile { text }?,
  attribute command { text }?,
  attribute package { text }?,
  attribute cvsroot { text }?,
  attribute reallyquiet { boolean }?,
  attribute starttag { text }?,
  attribute output { text }?,
  attribute port { text }?,
  attribute compressionlevel { text }?,
  attribute dest { text }?,
  attribute destfile { text }?,
  attribute enddate { text }?,
  attribute noexec { boolean }?,
  attribute error { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute date { text }?,
  attribute startdate { text }?,
  attribute ignoreremoved { boolean }?,
  attribute compression { boolean }?,
  attribute tag { text }?
module = element module { attlist.module, empty }
attlist.module &=
  attribute id { xsd:ID }?,
  attribute name { text }?
commandline =
  element commandline { attlist.commandline, (marker | argument)* }
attlist.commandline &=
  attribute id { xsd:ID }?,
  attribute executable { text }?
marker = element marker { attlist.marker, empty }
attlist.marker &=
  attribute id { xsd:ID }?,
  attribute prefix { text }?,
  attribute suffix { text }?
argument = element argument { attlist.argument, empty }
attlist.argument &=
  attribute id { xsd:ID }?,
  attribute line { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute pathref { xsd:IDREF }?,
  attribute prefix { text }?,
  attribute value { text }?,
  attribute suffix { text }?,
  attribute path { text }?
gunzip = element gunzip { attlist.gunzip, empty }
attlist.gunzip &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?,
  attribute srcresource { text }?,
  attribute src { text }?
propertyhelper =
  element propertyhelper { attlist.propertyhelper, delegate* }
attlist.propertyhelper &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?
delegate = element delegate { attlist.delegate, empty }
attlist.delegate &=
  attribute id { xsd:ID }?,
  attribute refid { text }?
sync = element sync { attlist.sync, (preserveintarget | fileset)* }
attlist.sync &=
  attribute id { xsd:ID }?,
  attribute verbose { boolean }?,
  attribute taskname { text }?,
  attribute todir { text }?,
  attribute overwrite { boolean }?,
  attribute includeemptydirs { boolean }?,
  attribute description { text }?,
  attribute granularity { text }?,
  attribute failonerror { boolean }?
preserveintarget =
  element preserveintarget {
    attlist.preserveintarget,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.preserveintarget &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute preserveemptydirs { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
ccmcheckintask =
  element ccmcheckintask { attlist.ccmcheckintask, fileset* }
attlist.ccmcheckintask &=
  attribute id { xsd:ID }?,
  attribute ccmaction { text }?,
  attribute task { text }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute ccmdir { text }?,
  attribute comment { text }?
uptodate =
  element uptodate {
    attlist.uptodate, (srcfiles | srcresources | mapper)*
  }
attlist.uptodate &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute value { text }?,
  attribute property { text }?,
  attribute targetfile { text }?,
  attribute srcfile { text }?
srcfiles =
  element srcfiles {
    attlist.srcfiles,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.srcfiles &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
srcresources = element srcresources { attlist.srcresources, empty }
attlist.srcresources &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
p4labelsync = element p4labelsync { attlist.p4labelsync, empty }
attlist.p4labelsync &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute simulationmode { boolean }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?,
  attribute delete { boolean }?,
  attribute add { boolean }?
loadfile = element loadfile { attlist.loadfile, filterchain* }
attlist.loadfile &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute quiet { boolean }?,
  attribute description { text }?,
  attribute encoding { text }?,
  attribute property { text }?,
  attribute failonerror { boolean }?,
  attribute srcfile { text }?
attrib =
  element attrib {
    attlist.attrib,
    (mapper
     | srcfile
     | targetfile
     | redirector
     | env
     | filelist
     | fileset
     | dirset
     | arg)*
  }
attlist.attrib &=
  attribute id { xsd:ID }?,
  attribute addsourcefile { boolean }?,
  attribute verbose { boolean }?,
  attribute parallel { boolean }?,
  attribute input { text }?,
  attribute executable { text }?,
  attribute force { boolean }?,
  attribute inputstring { text }?,
  attribute osfamily { text }?,
  attribute readonly { boolean }?,
  attribute searchpath { boolean }?,
  attribute relative { boolean }?,
  attribute skipemptyfilesets { boolean }?,
  attribute command { text }?,
  attribute forwardslash { boolean }?,
  attribute spawn { boolean }?,
  attribute hidden { boolean }?,
  attribute description { text }?,
  attribute vmlauncher { boolean }?,
  attribute file { text }?,
  attribute logerror { boolean }?,
  attribute errorproperty { text }?,
  attribute failonerror { boolean }?,
  attribute output { text }?,
  attribute error { text }?,
  attribute os { text }?,
  attribute dest { text }?,
  attribute resolveexecutable { boolean }?,
  attribute taskname { text }?,
  attribute resultproperty { text }?,
  attribute ignoremissing { boolean }?,
  attribute failifexecutionfails { boolean }?,
  attribute append { boolean }?,
  attribute timeout { text }?,
  attribute maxparallel { text }?,
  attribute system { boolean }?,
  attribute outputproperty { text }?,
  attribute archive { boolean }?,
  attribute dir { text }?,
  attribute newenvironment { boolean }?,
  attribute type { "file" | "dir" | "both" }?
defaultexcludes =
  element defaultexcludes { attlist.defaultexcludes, empty }
attlist.defaultexcludes &=
  attribute id { xsd:ID }?,
  attribute remove { text }?,
  attribute echo { boolean }?,
  attribute taskname { text }?,
  attribute default { boolean }?,
  attribute description { text }?,
  attribute add { text }?
blgenclient = element blgenclient { attlist.blgenclient, classpath* }
attlist.blgenclient &=
  attribute id { xsd:ID }?,
  attribute debug { boolean }?,
  attribute classpath { text }?,
  attribute mode { text }?,
  attribute ejbjar { text }?,
  attribute version { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute clientjar { text }?
renameext =
  element renameext {
    attlist.renameext,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.renameext &=
  attribute id { xsd:ID }?,
  attribute replace { boolean }?,
  attribute toextension { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute fromextension { text }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute srcdir { text }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute includes { text }?
replace =
  element replace {
    attlist.replace,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | replacefilter
     | or
     | contains
     | depend
     | replacetoken
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | replacevalue
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.replace &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute failonnoreplacements { boolean }?,
  attribute replacefilterresource { text }?,
  attribute encoding { text }?,
  attribute propertyfile { text }?,
  attribute summary { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute token { text }?,
  attribute followsymlinks { boolean }?,
  attribute propertyresource { text }?,
  attribute replacefilterfile { text }?,
  attribute casesensitive { boolean }?,
  attribute dir { text }?,
  attribute value { text }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute includesfile { text }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute preservelastmodified { boolean }?,
  attribute excludesfile { text }?
replacefilter =
  element replacefilter {
    attlist.replacefilter, (replacetoken | replacevalue)*
  }
attlist.replacefilter &=
  attribute id { xsd:ID }?,
  attribute token { text }?,
  attribute value { text }?,
  attribute property { text }?
replacetoken = element replacetoken { attlist.replacetoken, text }
attlist.replacetoken &=
  attribute id { xsd:ID }?,
  attribute expandproperties { boolean }?
replacevalue = element replacevalue { attlist.replacevalue, text }
attlist.replacevalue &=
  attribute id { xsd:ID }?,
  attribute expandproperties { boolean }?
unwar =
  element unwar { attlist.unwar, (fileset | patternset | mapper)* }
attlist.unwar &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute encoding { text }?,
  attribute failonemptyarchive { boolean }?,
  attribute overwrite { boolean }?,
  attribute scanforunicodeextrafields { boolean }?,
  attribute stripabsolutepathspec { boolean }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?
junitreport =
  element junitreport { attlist.junitreport, (report | fileset)* }
attlist.junitreport &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute todir { text }?,
  attribute description { text }?,
  attribute tofile { text }?
report = element report { attlist.report, param* }
attlist.report &=
  attribute id { xsd:ID }?,
  attribute todir { text }?,
  attribute styledir { text }?,
  attribute format { "frames" | "noframes" }?,
  attribute extension { text }?
xslt =
  element xslt {
    attlist.xslt,
    (patternset
     | exclude
     | \include
     | custom
     | present
     | none
     | sysproperty
     | not
     | type
     | factory
     | modified
     | param
     | or
     | contains
     | depend
     | classpath
     | different
     | size
     | majority
     | containsregexp
     | filename
     | xmlcatalog
     | selector
     | trace
     | includesfile
     | outputproperty
     | style
     | mapper
     | date
     | excludesfile
     | syspropertyset
     | depth
     | and)*
  }
attlist.xslt &=
  attribute id { xsd:ID }?,
  attribute force { boolean }?,
  attribute excludes { text }?,
  attribute suppresswarnings { boolean }?,
  attribute filenameparameter { text }?,
  attribute processor { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute basedir { text }?,
  attribute failonnoresources { boolean }?,
  attribute destdir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute scanincludeddirectories { boolean }?,
  attribute failontransformationerror { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute in { text }?,
  attribute extension { text }?,
  attribute xslresource { text }?,
  attribute classpath { text }?,
  attribute casesensitive { boolean }?,
  attribute reloadstylesheet { boolean }?,
  attribute filedirparameter { text }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute out { text }?,
  attribute includesfile { text }?,
  attribute style { text }?,
  attribute failonerror { boolean }?,
  attribute taskname { text }?,
  attribute excludesfile { text }?,
  attribute useimplicitfileset { boolean }?
factory = element factory { attlist.factory, \attribute* }
attlist.factory &=
  attribute id { xsd:ID }?,
  attribute name { text }?
trace = element trace { attlist.trace, empty }
attlist.trace &=
  attribute id { xsd:ID }?,
  attribute templates { boolean }?,
  attribute selection { boolean }?,
  attribute generation { boolean }?,
  attribute elements { boolean }?,
  attribute extension { boolean }?
outputproperty =
  element outputproperty { attlist.outputproperty, empty }
attlist.outputproperty &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute value { text }?
style = element style { attlist.style, empty }
attlist.style &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
syspropertyset =
  element syspropertyset {
    attlist.syspropertyset, (propertyref | propertyset | mapper)*
  }
attlist.syspropertyset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute dynamic { boolean }?,
  attribute negate { boolean }?
ccmcheckout = element ccmcheckout { attlist.ccmcheckout, fileset* }
attlist.ccmcheckout &=
  attribute id { xsd:ID }?,
  attribute ccmaction { text }?,
  attribute task { text }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute ccmdir { text }?,
  attribute comment { text }?
p4revert = element p4revert { attlist.p4revert, empty }
attlist.p4revert &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute revertonlyunchanged { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute change { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?
javac =
  element javac {
    attlist.javac,
    (patternset
     | exclude
     | \include
     | custom
     | present
     | none
     | extdirs
     | not
     | type
     | compilerclasspath
     | modified
     | src
     | or
     | contains
     | depend
     | classpath
     | sourcepath
     | different
     | size
     | majority
     | containsregexp
     | bootclasspath
     | filename
     | selector
     | includesfile
     | compilerarg
     | date
     | excludesfile
     | depth
     | and)*
  }
attlist.javac &=
  attribute id { xsd:ID }?,
  attribute target { text }?,
  attribute excludes { text }?,
  attribute verbose { boolean }?,
  attribute bootclasspathref { xsd:IDREF }?,
  attribute compiler { text }?,
  attribute executable { text }?,
  attribute debuglevel { text }?,
  attribute memoryinitialsize { text }?,
  attribute deprecation { boolean }?,
  attribute includeantruntime { boolean }?,
  attribute description { text }?,
  attribute sourcepathref { xsd:IDREF }?,
  attribute depend { boolean }?,
  attribute includes { text }?,
  attribute source { text }?,
  attribute includejavaruntime { boolean }?,
  attribute errorproperty { text }?,
  attribute failonerror { boolean }?,
  attribute destdir { text }?,
  attribute debug { boolean }?,
  attribute tempdir { text }?,
  attribute classpath { text }?,
  attribute followsymlinks { boolean }?,
  attribute casesensitive { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute bootclasspath { text }?,
  attribute includedestclasses { boolean }?,
  attribute includesfile { text }?,
  attribute updatedproperty { text }?,
  attribute nowarn { boolean }?,
  attribute proceed { boolean }?,
  attribute taskname { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute fork { boolean }?,
  attribute srcdir { text }?,
  attribute memorymaximumsize { text }?,
  attribute optimize { boolean }?,
  attribute encoding { text }?,
  attribute excludesfile { text }?,
  attribute sourcepath { text }?,
  attribute listfiles { boolean }?,
  attribute extdirs { text }?
compilerclasspath =
  element compilerclasspath {
    attlist.compilerclasspath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.compilerclasspath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
src =
  element src {
    attlist.src,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.src &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
compilerarg = element compilerarg { attlist.compilerarg, empty }
attlist.compilerarg &=
  attribute id { xsd:ID }?,
  attribute compiler { text }?,
  attribute file { text }?,
  attribute implementation { text }?,
  attribute pathref { xsd:IDREF }?,
  attribute prefix { text }?,
  attribute value { text }?,
  attribute description { text }?,
  attribute suffix { text }?,
  attribute path { text }?,
  attribute line { text }?
subant =
  element subant {
    attlist.subant,
    (reference
     | propertyset
     | filelist
     | target
     | fileset
     | dirset
     | buildpath
     | property
     | buildpathelement)*
  }
attlist.subant &=
  attribute id { xsd:ID }?,
  attribute genericantfile { text }?,
  attribute output { text }?,
  attribute inheritall { boolean }?,
  attribute verbose { boolean }?,
  attribute inheritrefs { boolean }?,
  attribute antfile { text }?,
  attribute target { text }?,
  attribute buildpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute buildpath { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?
reference = element reference { attlist.reference, empty }
attlist.reference &=
  attribute id { xsd:ID }?,
  attribute torefid { text }?,
  attribute refid { text }?
buildpath =
  element buildpath {
    attlist.buildpath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.buildpath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
property = element property { attlist.property, (text | classpath)* }
attlist.property &=
  attribute id { xsd:ID }?,
  attribute prefixvalues { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute name { text }?,
  attribute relative { boolean }?,
  attribute url { text }?,
  attribute classpath { text }?,
  attribute file { text }?,
  attribute userproperty { boolean }?,
  attribute resource { text }?,
  attribute environment { text }?,
  attribute prefix { text }?,
  attribute basedir { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute location { text }?,
  attribute value { text }?,
  attribute description { text }?
buildpathelement =
  element buildpathelement { attlist.buildpathelement, empty }
attlist.buildpathelement &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute path { text }?
vsscreate = element vsscreate { attlist.vsscreate, empty }
attlist.vsscreate &=
  attribute id { xsd:ID }?,
  attribute ssdir { text }?,
  attribute autoresponse { text }?,
  attribute quiet { boolean }?,
  attribute vsspath { text }?,
  attribute comment { text }?,
  attribute serverpath { text }?,
  attribute login { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?
splash = element splash { attlist.splash, empty }
attlist.splash &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute displaytext { text }?,
  attribute user { text }?,
  attribute progressregexp { text }?,
  attribute proxy { text }?,
  attribute taskname { text }?,
  attribute imageurl { text }?,
  attribute description { text }?,
  attribute password { text }?,
  attribute showduration { text }?,
  attribute useproxy { boolean }?
hostinfo = element hostinfo { attlist.hostinfo, empty }
attlist.hostinfo &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute host { text }?,
  attribute prefix { text }?
javah =
  element javah {
    attlist.javah,
    (implementationclasspath
     | arg
     | fileset
     | classpath
     | class
     | bootclasspath)*
  }
attlist.javah &=
  attribute id { xsd:ID }?,
  attribute stubs { boolean }?,
  attribute force { boolean }?,
  attribute destdir { text }?,
  attribute classpath { text }?,
  attribute old { boolean }?,
  attribute outputfile { text }?,
  attribute implementation { text }?,
  attribute class { text }?,
  attribute verbose { boolean }?,
  attribute bootclasspath { text }?,
  attribute bootclasspathref { xsd:IDREF }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute description { text }?
implementationclasspath =
  element implementationclasspath {
    attlist.implementationclasspath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.implementationclasspath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
class = element class { attlist.class, empty }
attlist.class &=
  attribute id { xsd:ID }?,
  attribute name { text }?
jarlib-resolve =
  element jarlib-resolve {
    attlist.jarlib-resolve, (ant | location | url | extension)*
  }
attlist.jarlib-resolve &=
  attribute id { xsd:ID }?,
  attribute checkextension { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute property { text }?,
  attribute failonerror { boolean }?
ant = element ant { attlist.ant, empty }
attlist.ant &=
  attribute id { xsd:ID }?,
  attribute target { text }?,
  attribute antfile { text }?,
  attribute destfile { text }?
location = element location { attlist.location, empty }
attlist.location &=
  attribute id { xsd:ID }?,
  attribute location { text }?
rmic =
  element rmic {
    attlist.rmic,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | extdirs
     | not
     | type
     | compilerclasspath
     | modified
     | or
     | contains
     | depend
     | classpath
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | compilerarg
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.rmic &=
  attribute id { xsd:ID }?,
  attribute verify { boolean }?,
  attribute excludes { text }?,
  attribute idlopts { text }?,
  attribute iiop { boolean }?,
  attribute extdirs { text }?,
  attribute sourcebase { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute base { text }?,
  attribute destdir { text }?,
  attribute executable { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute includeantruntime { boolean }?,
  attribute includejavaruntime { boolean }?,
  attribute classpath { text }?,
  attribute casesensitive { boolean }?,
  attribute compiler { text }?,
  attribute debug { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute includesfile { text }?,
  attribute taskname { text }?,
  attribute idl { boolean }?,
  attribute iiopopts { text }?,
  attribute classname { text }?,
  attribute excludesfile { text }?,
  attribute filtering { boolean }?,
  attribute stubversion { text }?,
  attribute listfiles { boolean }?
tstamp = element tstamp { attlist.tstamp, format* }
attlist.tstamp &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute prefix { text }?
format = element format { attlist.format, empty }
attlist.format &=
  attribute id { xsd:ID }?,
  attribute locale { text }?,
  attribute timezone { text }?,
  attribute unit {
    "millisecond"
    | "second"
    | "minute"
    | "hour"
    | "day"
    | "week"
    | "month"
    | "year"
  }?,
  attribute pattern { text }?,
  attribute property { text }?,
  attribute offset { text }?
echo = element echo { attlist.echo, text }
attlist.echo &=
  attribute id { xsd:ID }?,
  attribute level {
    "error" | "warn" | "warning" | "info" | "verbose" | "debug"
  }?,
  attribute force { boolean }?,
  attribute encoding { text }?,
  attribute append { boolean }?,
  attribute output { text }?,
  attribute file { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute message { text }?
soscheckin = element soscheckin { attlist.soscheckin, empty }
attlist.soscheckin &=
  attribute id { xsd:ID }?,
  attribute soshome { text }?,
  attribute file { text }?,
  attribute recursive { boolean }?,
  attribute verbose { boolean }?,
  attribute vssserverpath { text }?,
  attribute username { text }?,
  attribute sosserverpath { text }?,
  attribute comment { text }?,
  attribute projectpath { text }?,
  attribute nocache { boolean }?,
  attribute nocompress { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute localpath { text }?,
  attribute soscmd { text }?,
  attribute password { text }?
jarlib-manifest =
  element jarlib-manifest {
    attlist.jarlib-manifest,
    (options | \attribute | depends | extension)*
  }
attlist.jarlib-manifest &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute destfile { text }?
options =
  element options {
    attlist.options, (fileset | libfileset | extension)*
  }
attlist.options &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
depends =
  element depends {
    attlist.depends, (fileset | libfileset | extension)*
  }
attlist.depends &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
loadresource =
  element loadresource { attlist.loadresource, filterchain* }
attlist.loadresource &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute quiet { boolean }?,
  attribute description { text }?,
  attribute encoding { text }?,
  attribute property { text }?,
  attribute failonerror { boolean }?
jar =
  element jar {
    attlist.jar,
    (patternset
     | exclude
     | \include
     | custom
     | present
     | none
     | not
     | manifest
     | type
     | metainf
     | modified
     | or
     | contains
     | depend
     | fileset
     | different
     | size
     | majority
     | containsregexp
     | indexjars
     | filename
     | selector
     | includesfile
     | zipgroupfileset
     | zipfileset
     | date
     | excludesfile
     | depth
     | and
     | service)*
  }
attlist.jar &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute manifestencoding { text }?,
  attribute destfile { text }?,
  attribute indexmetainf { boolean }?,
  attribute level { text }?,
  attribute zipfile { text }?,
  attribute basedir { text }?,
  attribute manifest { text }?,
  attribute description { text }?,
  attribute includes { text }?,
  attribute keepcompression { boolean }?,
  attribute file { text }?,
  attribute whenmanifestonly { "fail" | "skip" | "create" }?,
  attribute duplicate { "add" | "preserve" | "fail" }?,
  attribute casesensitive { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute jarfile { text }?,
  attribute uselanguageencodingflag { boolean }?,
  attribute createunicodeextrafields {
    "never" | "always" | "not-encodeable"
  }?,
  attribute flattenattributes { boolean }?,
  attribute index { boolean }?,
  attribute includesfile { text }?,
  attribute update { boolean }?,
  attribute comment { text }?,
  attribute fallbacktoutf8 { boolean }?,
  attribute taskname { text }?,
  attribute strict { "fail" | "warn" | "ignore" }?,
  attribute roundup { boolean }?,
  attribute encoding { text }?,
  attribute excludesfile { text }?,
  attribute whenempty { "fail" | "skip" | "create" }?,
  attribute filesonly { boolean }?,
  attribute filesetmanifest { "skip" | "merge" | "mergewithoutmain" }?,
  attribute mergeclasspathattributes { boolean }?,
  attribute compress { boolean }?,
  attribute preserve0permissions { boolean }?
p4delete = element p4delete { attlist.p4delete, empty }
attlist.p4delete &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute change { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?
ccmklbtype = element ccmklbtype { attlist.ccmklbtype, empty }
attlist.ccmklbtype &=
  attribute id { xsd:ID }?,
  attribute global { boolean }?,
  attribute replace { boolean }?,
  attribute shared { boolean }?,
  attribute viewpath { text }?,
  attribute typename { text }?,
  attribute comment { text }?,
  attribute pbranch { boolean }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute cleartooldir { text }?,
  attribute taskname { text }?,
  attribute vob { text }?,
  attribute description { text }?,
  attribute commentfile { text }?,
  attribute ordinary { boolean }?
symlink = element symlink { attlist.symlink, fileset* }
attlist.symlink &=
  attribute id { xsd:ID }?,
  attribute linkfilename { text }?,
  attribute taskname { text }?,
  attribute overwrite { boolean }?,
  attribute description { text }?,
  attribute link { text }?,
  attribute action { text }?,
  attribute resource { text }?,
  attribute failonerror { boolean }?
vsscheckin = element vsscheckin { attlist.vsscheckin, empty }
attlist.vsscheckin &=
  attribute id { xsd:ID }?,
  attribute ssdir { text }?,
  attribute recursive { boolean }?,
  attribute autoresponse { text }?,
  attribute vsspath { text }?,
  attribute comment { text }?,
  attribute serverpath { text }?,
  attribute writable { boolean }?,
  attribute login { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute localpath { text }?
scriptdef =
  element scriptdef {
    attlist.scriptdef, (text | classpath | \element | \attribute)*
  }
attlist.scriptdef &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute name { text }?,
  attribute uri { text }?,
  attribute classpath { text }?,
  attribute manager { text }?,
  attribute language { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute loaderref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute reverseloader { boolean }?
\element = element element { attlist.element, empty }
attlist.element &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute type { text }?,
  attribute classname { text }?
dirname = element dirname { attlist.dirname, empty }
attlist.dirname &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute property { text }?
cclock = element cclock { attlist.cclock, empty }
attlist.cclock &=
  attribute id { xsd:ID }?,
  attribute objsel { text }?,
  attribute replace { boolean }?,
  attribute pname { text }?,
  attribute viewpath { text }?,
  attribute comment { text }?,
  attribute failonerr { boolean }?,
  attribute cleartooldir { text }?,
  attribute objselect { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute nusers { text }?,
  attribute obsolete { boolean }?
cvsversion =
  element cvsversion { attlist.cvsversion, (module | commandline)* }
attlist.cvsversion &=
  attribute id { xsd:ID }?,
  attribute cvsrsh { text }?,
  attribute quiet { boolean }?,
  attribute passfile { text }?,
  attribute command { text }?,
  attribute package { text }?,
  attribute cvsroot { text }?,
  attribute reallyquiet { boolean }?,
  attribute output { text }?,
  attribute port { text }?,
  attribute serverversionproperty { text }?,
  attribute dest { text }?,
  attribute compressionlevel { text }?,
  attribute clientversionproperty { text }?,
  attribute noexec { boolean }?,
  attribute error { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute date { text }?,
  attribute compression { boolean }?,
  attribute tag { text }?
get = element get { attlist.get, mapper* }
attlist.get &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute verbose { boolean }?,
  attribute skipexisting { boolean }?,
  attribute ignoreerrors { boolean }?,
  attribute username { text }?,
  attribute usetimestamp { boolean }?,
  attribute retries { text }?,
  attribute httpusecaches { boolean }?,
  attribute maxtime { text }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?,
  attribute password { text }?
condition =
  element condition {
    attlist.condition,
    (isfalse
     | isreference
     | equals
     | available
     | not
     | contains
     | os
     | or
     | and
     | filesmatch
     | checksum
     | istrue
     | isset
     | socket
     | http
     | uptodate
     | isfileselected)*
  }
attlist.condition &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute value { text }?,
  attribute property { text }?,
  attribute else { text }?
isfalse = element isfalse { attlist.isfalse, empty }
attlist.isfalse &=
  attribute id { xsd:ID }?,
  attribute description { text }?,
  attribute value { boolean }?
isreference = element isreference { attlist.isreference, empty }
attlist.isreference &=
  attribute id { xsd:ID }?,
  attribute type { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
equals = element equals { attlist.equals, empty }
attlist.equals &=
  attribute id { xsd:ID }?,
  attribute trim { boolean }?,
  attribute arg2 { text }?,
  attribute arg1 { text }?,
  attribute casesensitive { boolean }?,
  attribute forcestring { boolean }?
os = element os { attlist.os, empty }
attlist.os &=
  attribute id { xsd:ID }?,
  attribute version { text }?,
  attribute name { text }?,
  attribute family { text }?,
  attribute arch { text }?
filesmatch = element filesmatch { attlist.filesmatch, empty }
attlist.filesmatch &=
  attribute id { xsd:ID }?,
  attribute file2 { text }?,
  attribute file1 { text }?,
  attribute textfile { boolean }?
checksum =
  element checksum {
    attlist.checksum,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | fileset
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.checksum &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute fileext { text }?,
  attribute totalproperty { text }?,
  attribute property { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute casesensitive { boolean }?,
  attribute readbuffersize { text }?,
  attribute verifyproperty { text }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute todir { text }?,
  attribute algorithm { text }?,
  attribute includesfile { text }?,
  attribute format { "CHECKSUM" | "MD5SUM" | "SVF" }?,
  attribute pattern { text }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute excludesfile { text }?,
  attribute provider { text }?,
  attribute forceoverwrite { boolean }?
istrue = element istrue { attlist.istrue, empty }
attlist.istrue &=
  attribute id { xsd:ID }?,
  attribute description { text }?,
  attribute value { boolean }?
isset = element isset { attlist.isset, empty }
attlist.isset &=
  attribute id { xsd:ID }?,
  attribute description { text }?,
  attribute property { text }?
socket = element socket { attlist.socket, empty }
attlist.socket &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute description { text }?,
  attribute server { text }?
http = element http { attlist.http, empty }
attlist.http &=
  attribute id { xsd:ID }?,
  attribute url { text }?,
  attribute description { text }?,
  attribute requestmethod { text }?,
  attribute errorsbeginat { text }?
script = element script { attlist.script, (text | classpath)* }
attlist.script &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute taskname { text }?,
  attribute manager { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute description { text }?,
  attribute setbeans { boolean }?,
  attribute src { text }?,
  attribute language { text }?
typedef = element typedef { attlist.typedef, classpath* }
attlist.typedef &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute uri { text }?,
  attribute classpath { text }?,
  attribute file { text }?,
  attribute classname { text }?,
  attribute resource { text }?,
  attribute antlib { text }?,
  attribute adaptto { text }?,
  attribute onerror { "fail" | "report" | "ignore" | "failall" }?,
  attribute loaderref { xsd:IDREF }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute adapter { text }?,
  attribute format { "properties" | "xml" }?,
  attribute description { text }?,
  attribute reverseloader { boolean }?
input = element input { attlist.input, (text | handler)* }
attlist.input &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute addproperty { text }?,
  attribute description { text }?,
  attribute defaultvalue { text }?,
  attribute validargs { text }?,
  attribute message { text }?
handler = element handler { attlist.handler, classpath* }
attlist.handler &=
  attribute id { xsd:ID }?,
  attribute refid { text }?,
  attribute uri { text }?,
  attribute classpath { text }?,
  attribute classname { text }?,
  attribute type { "default" | "propertyfile" | "greedy" | "secure" }?,
  attribute classpathref { xsd:IDREF }?,
  attribute loaderref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute reverseloader { boolean }?
waitfor =
  element waitfor {
    attlist.waitfor,
    (isfalse
     | isreference
     | equals
     | available
     | not
     | contains
     | os
     | or
     | and
     | filesmatch
     | checksum
     | istrue
     | isset
     | socket
     | http
     | uptodate
     | isfileselected)*
  }
attlist.waitfor &=
  attribute id { xsd:ID }?,
  attribute checkeveryunit {
    "millisecond" | "second" | "minute" | "hour" | "day" | "week"
  }?,
  attribute checkevery { text }?,
  attribute maxwaitunit {
    "millisecond" | "second" | "minute" | "hour" | "day" | "week"
  }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute maxwait { text }?,
  attribute timeoutproperty { text }?
taskdef = element taskdef { attlist.taskdef, classpath* }
attlist.taskdef &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute uri { text }?,
  attribute classpath { text }?,
  attribute file { text }?,
  attribute classname { text }?,
  attribute resource { text }?,
  attribute antlib { text }?,
  attribute adaptto { text }?,
  attribute onerror { "fail" | "report" | "ignore" | "failall" }?,
  attribute loaderref { xsd:IDREF }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute adapter { text }?,
  attribute format { "properties" | "xml" }?,
  attribute description { text }?,
  attribute reverseloader { boolean }?
sound = element sound { attlist.sound, (fail | success)* }
attlist.sound &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?
fail = element fail { attlist.fail, empty }
attlist.fail &=
  attribute id { xsd:ID }?,
  attribute loops { text }?,
  attribute source { text }?,
  attribute duration { text }?
success = element success { attlist.success, empty }
attlist.success &=
  attribute id { xsd:ID }?,
  attribute loops { text }?,
  attribute source { text }?,
  attribute duration { text }?
ftp = element ftp { attlist.ftp, fileset* }
attlist.ftp &=
  attribute id { xsd:ID }?,
  attribute binary { boolean }?,
  attribute shortmonthnamesconfig { text }?,
  attribute password { text }?,
  attribute userid { text }?,
  attribute timediffauto { boolean }?,
  attribute remotedir { text }?,
  attribute account { text }?,
  attribute systemtypekey { text }?,
  attribute separator { text }?,
  attribute initialsitecommand { text }?,
  attribute port { text }?,
  attribute sitecommand { text }?,
  attribute timestampgranularity { "MINUTE" | "NONE" }?,
  attribute skipfailedtransfers { boolean }?,
  attribute retriesallowed { text }?,
  attribute chmod { text }?,
  attribute timediffmillis { text }?,
  attribute verbose { boolean }?,
  attribute defaultdateformatconfig { text }?,
  attribute server { text }?,
  attribute servertimezoneconfig { text }?,
  attribute newer { boolean }?,
  attribute action {
    "send"
    | "put"
    | "recv"
    | "get"
    | "del"
    | "delete"
    | "list"
    | "mkdir"
    | "chmod"
    | "rmdir"
    | "site"
  }?,
  attribute description { text }?,
  attribute passive { boolean }?,
  attribute taskname { text }?,
  attribute serverlanguagecodeconfig {
    "da"
    | "de"
    | "en"
    | "es"
    | "fr"
    | "it"
    | "nl"
    | "no"
    | "pt"
    | "ro"
    | "sh"
    | "sk"
    | "sl"
    | "sq"
    | "sv"
  }?,
  attribute recentdateformatconfig { text }?,
  attribute preservelastmodified { boolean }?,
  attribute listing { text }?,
  attribute umask { text }?,
  attribute ignorenoncriticalerrors { boolean }?,
  attribute enableremoteverification { boolean }?,
  attribute depends { boolean }?
exec = element exec { attlist.exec, (arg | redirector | env)* }
attlist.exec &=
  attribute id { xsd:ID }?,
  attribute resultproperty { text }?,
  attribute command { text }?,
  attribute failifexecutionfails { boolean }?,
  attribute executable { text }?,
  attribute osfamily { text }?,
  attribute errorproperty { text }?,
  attribute os { text }?,
  attribute output { text }?,
  attribute timeout { text }?,
  attribute spawn { boolean }?,
  attribute input { text }?,
  attribute inputstring { text }?,
  attribute searchpath { boolean }?,
  attribute logerror { boolean }?,
  attribute dir { text }?,
  attribute error { text }?,
  attribute description { text }?,
  attribute outputproperty { text }?,
  attribute failonerror { boolean }?,
  attribute resolveexecutable { boolean }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute newenvironment { boolean }?,
  attribute vmlauncher { boolean }?
ccmkelem = element ccmkelem { attlist.ccmkelem, empty }
attlist.ccmkelem &=
  attribute id { xsd:ID }?,
  attribute preservetime { boolean }?,
  attribute master { boolean }?,
  attribute eltype { text }?,
  attribute viewpath { text }?,
  attribute comment { text }?,
  attribute nowarn { boolean }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute cleartooldir { text }?,
  attribute taskname { text }?,
  attribute nocheckout { boolean }?,
  attribute description { text }?,
  attribute commentfile { text }?,
  attribute checkin { boolean }?
diagnostics = element diagnostics { attlist.diagnostics, empty }
attlist.diagnostics &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?
iplanet-ejbc = element iplanet-ejbc { attlist.iplanet-ejbc, classpath* }
attlist.iplanet-ejbc &=
  attribute id { xsd:ID }?,
  attribute ejbdescriptor { text }?,
  attribute debug { boolean }?,
  attribute classpath { text }?,
  attribute iasdescriptor { text }?,
  attribute iashome { text }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?,
  attribute keepgenerated { boolean }?
jspc =
  element jspc {
    attlist.jspc,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | compilerclasspath
     | modified
     | or
     | contains
     | depend
     | classpath
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | webapp
     | and
     | depth)*
  }
attlist.jspc &=
  attribute id { xsd:ID }?,
  attribute mapped { boolean }?,
  attribute ieplugin { text }?,
  attribute excludes { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute package { text }?,
  attribute destdir { text }?,
  attribute compilerclasspath { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute uribase { text }?,
  attribute classpath { text }?,
  attribute casesensitive { boolean }?,
  attribute verbose { text }?,
  attribute compiler { text }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute webxml { text }?,
  attribute includesfile { text }?,
  attribute failonerror { boolean }?,
  attribute taskname { text }?,
  attribute srcdir { text }?,
  attribute excludesfile { text }?,
  attribute uriroot { text }?,
  attribute webinc { text }?
webapp = element webapp { attlist.webapp, empty }
attlist.webapp &=
  attribute id { xsd:ID }?,
  attribute basedir { text }?
p4fstat = element p4fstat { attlist.p4fstat, fileset* }
attlist.p4fstat &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute changelist { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?,
  attribute showfilter { text }?
chown =
  element chown {
    attlist.chown,
    (mapper
     | srcfile
     | targetfile
     | redirector
     | env
     | filelist
     | fileset
     | dirset
     | arg)*
  }
attlist.chown &=
  attribute id { xsd:ID }?,
  attribute addsourcefile { boolean }?,
  attribute verbose { boolean }?,
  attribute parallel { boolean }?,
  attribute input { text }?,
  attribute executable { text }?,
  attribute force { boolean }?,
  attribute inputstring { text }?,
  attribute osfamily { text }?,
  attribute searchpath { boolean }?,
  attribute relative { boolean }?,
  attribute skipemptyfilesets { boolean }?,
  attribute command { text }?,
  attribute forwardslash { boolean }?,
  attribute spawn { boolean }?,
  attribute description { text }?,
  attribute vmlauncher { boolean }?,
  attribute file { text }?,
  attribute logerror { boolean }?,
  attribute errorproperty { text }?,
  attribute failonerror { boolean }?,
  attribute output { text }?,
  attribute error { text }?,
  attribute os { text }?,
  attribute owner { text }?,
  attribute dest { text }?,
  attribute resolveexecutable { boolean }?,
  attribute taskname { text }?,
  attribute resultproperty { text }?,
  attribute ignoremissing { boolean }?,
  attribute failifexecutionfails { boolean }?,
  attribute append { boolean }?,
  attribute timeout { text }?,
  attribute maxparallel { text }?,
  attribute outputproperty { text }?,
  attribute dir { text }?,
  attribute newenvironment { boolean }?,
  attribute type { "file" | "dir" | "both" }?
sosget = element sosget { attlist.sosget, empty }
attlist.sosget &=
  attribute id { xsd:ID }?,
  attribute soshome { text }?,
  attribute file { text }?,
  attribute recursive { boolean }?,
  attribute verbose { boolean }?,
  attribute vssserverpath { text }?,
  attribute username { text }?,
  attribute sosserverpath { text }?,
  attribute projectpath { text }?,
  attribute version { text }?,
  attribute nocompress { boolean }?,
  attribute nocache { boolean }?,
  attribute taskname { text }?,
  attribute label { text }?,
  attribute description { text }?,
  attribute localpath { text }?,
  attribute soscmd { text }?,
  attribute password { text }?
cab =
  element cab {
    attlist.cab,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | fileset
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.cab &=
  attribute id { xsd:ID }?,
  attribute cabfile { text }?,
  attribute compress { boolean }?,
  attribute verbose { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute basedir { text }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute includesfile { text }?,
  attribute excludes { text }?,
  attribute includes { text }?,
  attribute options { text }?
tempfile = element tempfile { attlist.tempfile, empty }
attlist.tempfile &=
  attribute id { xsd:ID }?,
  attribute destdir { text }?,
  attribute deleteonexit { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute prefix { text }?,
  attribute property { text }?,
  attribute suffix { text }?,
  attribute createfile { boolean }?
sequential = element sequential { attlist.sequential, tasks* }
attlist.sequential &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?
bzip2 = element bzip2 { attlist.bzip2, empty }
attlist.bzip2 &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute zipfile { text }?,
  attribute description { text }?,
  attribute srcresource { text }?,
  attribute src { text }?,
  attribute destfile { text }?
bunzip2 = element bunzip2 { attlist.bunzip2, empty }
attlist.bunzip2 &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?,
  attribute srcresource { text }?,
  attribute src { text }?
cvspass = element cvspass { attlist.cvspass, empty }
attlist.cvspass &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute password { text }?,
  attribute description { text }?,
  attribute cvsroot { text }?,
  attribute passfile { text }?
makeurl = element makeurl { attlist.makeurl, (fileset | path)* }
attlist.makeurl &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute property { text }?,
  attribute separator { text }?,
  attribute validate { boolean }?
copydir =
  element copydir {
    attlist.copydir,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.copydir &=
  attribute id { xsd:ID }?,
  attribute flatten { boolean }?,
  attribute src { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute dest { text }?,
  attribute description { text }?,
  attribute forceoverwrite { boolean }?,
  attribute excludesfile { text }?,
  attribute includesfile { text }?,
  attribute excludes { text }?,
  attribute filtering { boolean }?,
  attribute includes { text }?
rexec = element rexec { attlist.rexec, (write | read)* }
attlist.rexec &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute server { text }?,
  attribute command { text }?,
  attribute userid { text }?,
  attribute timeout { text }?,
  attribute initialcr { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute password { text }?
write = element write { attlist.write, text }
attlist.write &=
  attribute id { xsd:ID }?,
  attribute string { text }?
read = element read { attlist.read, text }
attlist.read &=
  attribute id { xsd:ID }?,
  attribute string { text }?
javacc = element javacc { attlist.javacc, empty }
attlist.javacc &=
  attribute id { xsd:ID }?,
  attribute jdkversion { text }?,
  attribute debugparser { boolean }?,
  attribute javacchome { text }?,
  attribute forcelacheck { boolean }?,
  attribute optimizetokenmanager { boolean }?,
  attribute commontokenaction { boolean }?,
  attribute buildtokenmanager { boolean }?,
  attribute sanitycheck { boolean }?,
  attribute buildparser { boolean }?,
  attribute otherambiguitycheck { text }?,
  attribute lookahead { text }?,
  attribute debuglookahead { boolean }?,
  attribute choiceambiguitycheck { text }?,
  attribute unicodeinput { boolean }?,
  attribute usercharstream { boolean }?,
  attribute debugtokenmanager { boolean }?,
  attribute keeplinecolumn { boolean }?,
  attribute description { text }?,
  attribute taskname { text }?,
  attribute outputdirectory { text }?,
  attribute cachetokens { boolean }?,
  attribute javaunicodeescape { boolean }?,
  attribute static { boolean }?,
  attribute target { text }?,
  attribute ignorecase { boolean }?,
  attribute usertokenmanager { boolean }?,
  attribute errorreporting { boolean }?
soscheckout = element soscheckout { attlist.soscheckout, empty }
attlist.soscheckout &=
  attribute id { xsd:ID }?,
  attribute soshome { text }?,
  attribute file { text }?,
  attribute recursive { boolean }?,
  attribute verbose { boolean }?,
  attribute vssserverpath { text }?,
  attribute username { text }?,
  attribute sosserverpath { text }?,
  attribute projectpath { text }?,
  attribute nocache { boolean }?,
  attribute nocompress { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute localpath { text }?,
  attribute soscmd { text }?,
  attribute password { text }?
ccmkbl = element ccmkbl { attlist.ccmkbl, empty }
attlist.ccmkbl &=
  attribute id { xsd:ID }?,
  attribute viewpath { text }?,
  attribute comment { text }?,
  attribute nlabel { boolean }?,
  attribute full { boolean }?,
  attribute nowarn { boolean }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute cleartooldir { text }?,
  attribute identical { boolean }?,
  attribute taskname { text }?,
  attribute baselinerootname { text }?,
  attribute description { text }?,
  attribute commentfile { text }?
p4reopen = element p4reopen { attlist.p4reopen, empty }
attlist.p4reopen &=
  attribute id { xsd:ID }?,
  attribute tochange { text }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?
parallel = element parallel { attlist.parallel, (tasks | daemons)* }
attlist.parallel &=
  attribute id { xsd:ID }?,
  attribute pollinterval { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute threadsperprocessor { text }?,
  attribute timeout { text }?,
  attribute threadcount { text }?,
  attribute failonany { boolean }?
daemons = element daemons { attlist.daemons, tasks* }
attlist.daemons &= attribute id { xsd:ID }?
mail =
  element mail {
    attlist.mail,
    (replyto
     | cc
     | attachments
     | header
     | bcc
     | fileset
     | from
     | to
     | message)*
  }
attlist.mail &=
  attribute id { xsd:ID }?,
  attribute cclist { text }?,
  attribute messagefile { text }?,
  attribute password { text }?,
  attribute encoding { "auto" | "mime" | "uu" | "plain" }?,
  attribute charset { text }?,
  attribute files { text }?,
  attribute subject { text }?,
  attribute ignoreinvalidrecipients { boolean }?,
  attribute message { text }?,
  attribute ssl { boolean }?,
  attribute enablestarttls { boolean }?,
  attribute tolist { text }?,
  attribute mailport { text }?,
  attribute messagemimetype { text }?,
  attribute bcclist { text }?,
  attribute from { text }?,
  attribute description { text }?,
  attribute replyto { text }?,
  attribute mailhost { text }?,
  attribute failonerror { boolean }?,
  attribute taskname { text }?,
  attribute includefilenames { boolean }?,
  attribute user { text }?
replyto = element replyto { attlist.replyto, empty }
attlist.replyto &=
  attribute id { xsd:ID }?,
  attribute address { text }?,
  attribute name { text }?
cc = element cc { attlist.cc, empty }
attlist.cc &=
  attribute id { xsd:ID }?,
  attribute address { text }?,
  attribute name { text }?
attachments =
  element attachments {
    attlist.attachments,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.attachments &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
bcc = element bcc { attlist.bcc, empty }
attlist.bcc &=
  attribute id { xsd:ID }?,
  attribute address { text }?,
  attribute name { text }?
from = element from { attlist.from, empty }
attlist.from &=
  attribute id { xsd:ID }?,
  attribute address { text }?,
  attribute name { text }?
to = element to { attlist.to, empty }
attlist.to &=
  attribute id { xsd:ID }?,
  attribute address { text }?,
  attribute name { text }?
message = element message { attlist.message, text }
attlist.message &=
  attribute id { xsd:ID }?,
  attribute mimetype { text }?,
  attribute description { text }?,
  attribute src { text }?,
  attribute charset { text }?
p4sync = element p4sync { attlist.p4sync, empty }
attlist.p4sync &=
  attribute id { xsd:ID }?,
  attribute force { text }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute label { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?
junit =
  element junit {
    attlist.junit,
    (classpath
     | sysproperty
     | bootclasspath
     | syspropertyset
     | env
     | permissions
     | test
     | jvmarg
     | formatter
     | batchtest
     | assertions)*
  }
attlist.junit &=
  attribute id { xsd:ID }?,
  attribute fork { boolean }?,
  attribute haltonerror { boolean }?,
  attribute maxmemory { text }?,
  attribute printsummary {
    "true" | "yes" | "false" | "no" | "on" | "off" | "withOutAndErr"
  }?,
  attribute haltonfailure { boolean }?,
  attribute failureproperty { text }?,
  attribute enabletestlistenerevents { boolean }?,
  attribute showoutput { boolean }?,
  attribute errorproperty { text }?,
  attribute logfailedtests { boolean }?,
  attribute timeout { text }?,
  attribute tempdir { text }?,
  attribute outputtoformatters { boolean }?,
  attribute jvm { text }?,
  attribute includeantruntime { boolean }?,
  attribute dir { text }?,
  attribute filtertrace { boolean }?,
  attribute description { text }?,
  attribute forkmode { "once" | "perTest" | "perBatch" }?,
  attribute taskname { text }?,
  attribute newenvironment { boolean }?,
  attribute clonevm { boolean }?,
  attribute reloading { boolean }?
permissions =
  element permissions { attlist.permissions, (grant | revoke)* }
attlist.permissions &= attribute id { xsd:ID }?
grant = element grant { attlist.grant, empty }
attlist.grant &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute class { text }?,
  attribute actions { text }?
revoke = element revoke { attlist.revoke, empty }
attlist.revoke &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute class { text }?,
  attribute actions { text }?
test = element test { attlist.test, formatter* }
attlist.test &=
  attribute id { xsd:ID }?,
  attribute if { text }?,
  attribute unless { text }?,
  attribute name { text }?,
  attribute haltonerror { boolean }?,
  attribute fork { boolean }?,
  attribute todir { text }?,
  attribute methods { text }?,
  attribute outfile { text }?,
  attribute failureproperty { text }?,
  attribute runtime { text }?,
  attribute filtertrace { boolean }?,
  attribute haltonfailure { boolean }?,
  attribute errorproperty { text }?
formatter = element formatter { attlist.formatter, empty }
attlist.formatter &=
  attribute id { xsd:ID }?,
  attribute usefile { boolean }?,
  attribute type { "plain" | "xml" | "brief" | "failure" }?,
  attribute classname { text }?,
  attribute unless { text }?,
  attribute if { text }?,
  attribute extension { text }?
jvmarg = element jvmarg { attlist.jvmarg, empty }
attlist.jvmarg &=
  attribute id { xsd:ID }?,
  attribute line { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute pathref { xsd:IDREF }?,
  attribute prefix { text }?,
  attribute value { text }?,
  attribute suffix { text }?,
  attribute path { text }?
batchtest =
  element batchtest { attlist.batchtest, (fileset | formatter)* }
attlist.batchtest &=
  attribute id { xsd:ID }?,
  attribute if { text }?,
  attribute unless { text }?,
  attribute haltonerror { boolean }?,
  attribute fork { boolean }?,
  attribute todir { text }?,
  attribute failureproperty { text }?,
  attribute filtertrace { boolean }?,
  attribute haltonfailure { boolean }?,
  attribute errorproperty { text }?
telnet = element telnet { attlist.telnet, (write | read)* }
attlist.telnet &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute userid { text }?,
  attribute taskname { text }?,
  attribute password { text }?,
  attribute initialcr { boolean }?,
  attribute description { text }?,
  attribute timeout { text }?,
  attribute server { text }?
pathconvert =
  element pathconvert { attlist.pathconvert, (map | path | mapper)* }
attlist.pathconvert &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute pathsep { text }?,
  attribute setonempty { boolean }?,
  attribute preserveduplicates { boolean }?,
  attribute taskname { text }?,
  attribute dirsep { text }?,
  attribute description { text }?,
  attribute property { text }?,
  attribute targetos { text }?
map = element map { attlist.map, empty }
attlist.map &=
  attribute id { xsd:ID }?,
  attribute to { text }?,
  attribute from { text }?
classloader = element classloader { attlist.classloader, classpath* }
attlist.classloader &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute classpath { text }?,
  attribute parentfirst { boolean }?,
  attribute reset { boolean }?,
  attribute reverse { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute parentname { text }?
java =
  element java {
    attlist.java,
    (classpath
     | sysproperty
     | bootclasspath
     | redirector
     | syspropertyset
     | env
     | permissions
     | jvmarg
     | arg
     | assertions)*
  }
attlist.java &=
  attribute id { xsd:ID }?,
  attribute resultproperty { text }?,
  attribute jvmargs { text }?,
  attribute args { text }?,
  attribute fork { boolean }?,
  attribute maxmemory { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute jar { text }?,
  attribute errorproperty { text }?,
  attribute output { text }?,
  attribute timeout { text }?,
  attribute spawn { boolean }?,
  attribute input { text }?,
  attribute jvm { text }?,
  attribute inputstring { text }?,
  attribute classpath { text }?,
  attribute logerror { boolean }?,
  attribute dir { text }?,
  attribute error { text }?,
  attribute description { text }?,
  attribute jvmversion { text }?,
  attribute outputproperty { text }?,
  attribute failonerror { boolean }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute newenvironment { boolean }?,
  attribute classname { text }?,
  attribute clonevm { boolean }?
soslabel = element soslabel { attlist.soslabel, empty }
attlist.soslabel &=
  attribute id { xsd:ID }?,
  attribute soshome { text }?,
  attribute verbose { boolean }?,
  attribute vssserverpath { text }?,
  attribute username { text }?,
  attribute sosserverpath { text }?,
  attribute comment { text }?,
  attribute projectpath { text }?,
  attribute version { text }?,
  attribute nocache { boolean }?,
  attribute nocompress { boolean }?,
  attribute taskname { text }?,
  attribute label { text }?,
  attribute description { text }?,
  attribute localpath { text }?,
  attribute soscmd { text }?,
  attribute password { text }?
vsscheckout = element vsscheckout { attlist.vsscheckout, empty }
attlist.vsscheckout &=
  attribute id { xsd:ID }?,
  attribute ssdir { text }?,
  attribute date { text }?,
  attribute recursive { boolean }?,
  attribute autoresponse { text }?,
  attribute vsspath { text }?,
  attribute getlocalcopy { boolean }?,
  attribute version { text }?,
  attribute serverpath { text }?,
  attribute login { text }?,
  attribute filetimestamp { "current" | "modified" | "updated" }?,
  attribute taskname { text }?,
  attribute label { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute localpath { text }?,
  attribute writablefiles { "replace" | "skip" | "fail" }?
javadoc =
  element javadoc {
    attlist.javadoc,
    (taglet
     | doclet
     | package
     | arg
     | link
     | doctitle
     | bottom
     | group
     | packageset
     | fileset
     | classpath
     | sourcepath
     | footer
     | source
     | bootclasspath
     | header
     | excludepackage
     | sourcefiles
     | tag)*
  }
attlist.javadoc &=
  attribute id { xsd:ID }?,
  attribute bottom { text }?,
  attribute verbose { boolean }?,
  attribute bootclasspathref { xsd:IDREF }?,
  attribute executable { text }?,
  attribute header { text }?,
  attribute docfilessubdirs { boolean }?,
  attribute link { text }?,
  attribute noindex { boolean }?,
  attribute access { "protected" | "public" | "package" | "private" }?,
  attribute doclet { text }?,
  attribute noqualifier { text }?,
  attribute public { boolean }?,
  attribute author { boolean }?,
  attribute footer { text }?,
  attribute docletpath { text }?,
  attribute package { boolean }?,
  attribute useexternalfile { boolean }?,
  attribute description { text }?,
  attribute sourcepathref { xsd:IDREF }?,
  attribute protected { boolean }?,
  attribute breakiterator { boolean }?,
  attribute nonavbar { boolean }?,
  attribute maxmemory { text }?,
  attribute group { text }?,
  attribute source { text }?,
  attribute linkoffline { text }?,
  attribute additionalparam { text }?,
  attribute locale { text }?,
  attribute linksource { boolean }?,
  attribute failonerror { boolean }?,
  attribute destdir { text }?,
  attribute classpath { text }?,
  attribute defaultexcludes { boolean }?,
  attribute includenosourcepackages { boolean }?,
  attribute bootclasspath { text }?,
  attribute private { boolean }?,
  attribute taskname { text }?,
  attribute charset { text }?,
  attribute nodeprecatedlist { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute stylesheetfile { text }?,
  attribute docencoding { text }?,
  attribute excludepackagenames { text }?,
  attribute docletpathref { xsd:IDREF }?,
  attribute packagenames { text }?,
  attribute windowtitle { text }?,
  attribute notree { boolean }?,
  attribute splitindex { boolean }?,
  attribute encoding { text }?,
  attribute packagelist { text }?,
  attribute doctitle { text }?,
  attribute serialwarn { boolean }?,
  attribute old { boolean }?,
  attribute use { boolean }?,
  attribute sourcepath { text }?,
  attribute helpfile { text }?,
  attribute version { boolean }?,
  attribute sourcefiles { text }?,
  attribute extdirs { text }?,
  attribute excludedocfilessubdir { text }?,
  attribute nohelp { boolean }?,
  attribute nodeprecated { boolean }?,
  attribute overview { text }?
antcall =
  element antcall {
    attlist.antcall, (reference | propertyset | target | param)*
  }
attlist.antcall &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute inheritall { boolean }?,
  attribute inheritrefs { boolean }?,
  attribute description { text }?,
  attribute target { text }?
jjdoc = element jjdoc { attlist.jjdoc, empty }
attlist.jjdoc &=
  attribute id { xsd:ID }?,
  attribute outputfile { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute javacchome { text }?,
  attribute target { text }?,
  attribute text { boolean }?,
  attribute onetable { boolean }?
echoproperties =
  element echoproperties { attlist.echoproperties, propertyset* }
attlist.echoproperties &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute regex { text }?,
  attribute prefix { text }?,
  attribute format { "xml" | "text" }?,
  attribute srcfile { text }?,
  attribute failonerror { boolean }?,
  attribute destfile { text }?
basename = element basename { attlist.basename, empty }
attlist.basename &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?,
  attribute property { text }?,
  attribute suffix { text }?
rpm = element rpm { attlist.rpm, empty }
attlist.rpm &=
  attribute id { xsd:ID }?,
  attribute removesource { boolean }?,
  attribute output { text }?,
  attribute quiet { boolean }?,
  attribute command { text }?,
  attribute cleanbuilddir { boolean }?,
  attribute removespec { boolean }?,
  attribute error { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute specfile { text }?,
  attribute topdir { text }?,
  attribute rpmbuildcommand { text }?
import = element import { attlist.import, empty }
attlist.import &=
  attribute id { xsd:ID }?,
  attribute prefixseparator { text }?,
  attribute as { text }?,
  attribute taskname { text }?,
  attribute optional { boolean }?,
  attribute file { text }?,
  attribute description { text }?
p4submit = element p4submit { attlist.p4submit, empty }
attlist.p4submit &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute needsresolveproperty { text }?,
  attribute user { text }?,
  attribute changeproperty { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute change { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?
deltree = element deltree { attlist.deltree, empty }
attlist.deltree &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute dir { text }?,
  attribute description { text }?
move =
  element move {
    attlist.move, (filterchain | fileset | filterset | mapper)*
  }
attlist.move &=
  attribute id { xsd:ID }?,
  attribute flatten { boolean }?,
  attribute force { boolean }?,
  attribute encoding { text }?,
  attribute tofile { text }?,
  attribute todir { text }?,
  attribute file { text }?,
  attribute verbose { boolean }?,
  attribute includeemptydirs { boolean }?,
  attribute overwrite { boolean }?,
  attribute enablemultiplemappings { boolean }?,
  attribute granularity { text }?,
  attribute outputencoding { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute preservelastmodified { boolean }?,
  attribute filtering { boolean }?
mimemail =
  element mimemail {
    attlist.mimemail,
    (replyto
     | cc
     | attachments
     | header
     | bcc
     | fileset
     | from
     | to
     | message)*
  }
attlist.mimemail &=
  attribute id { xsd:ID }?,
  attribute cclist { text }?,
  attribute messagefile { text }?,
  attribute password { text }?,
  attribute encoding { "auto" | "mime" | "uu" | "plain" }?,
  attribute charset { text }?,
  attribute files { text }?,
  attribute subject { text }?,
  attribute ignoreinvalidrecipients { boolean }?,
  attribute message { text }?,
  attribute ssl { boolean }?,
  attribute enablestarttls { boolean }?,
  attribute tolist { text }?,
  attribute mailport { text }?,
  attribute messagemimetype { text }?,
  attribute bcclist { text }?,
  attribute from { text }?,
  attribute description { text }?,
  attribute replyto { text }?,
  attribute mailhost { text }?,
  attribute failonerror { boolean }?,
  attribute taskname { text }?,
  attribute includefilenames { boolean }?,
  attribute user { text }?
jlink =
  element jlink {
    attlist.jlink,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | mergefiles
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | addfiles
     | and
     | depth)*
  }
attlist.jlink &=
  attribute id { xsd:ID }?,
  attribute outfile { text }?,
  attribute compress { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute addfiles { text }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute mergefiles { text }?,
  attribute includes { text }?
mergefiles =
  element mergefiles {
    attlist.mergefiles,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.mergefiles &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
addfiles =
  element addfiles {
    attlist.addfiles,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.addfiles &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
untar =
  element untar { attlist.untar, (fileset | patternset | mapper)* }
attlist.untar &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute encoding { text }?,
  attribute failonemptyarchive { boolean }?,
  attribute overwrite { boolean }?,
  attribute scanforunicodeextrafields { boolean }?,
  attribute stripabsolutepathspec { boolean }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?,
  attribute compression { "none" | "gzip" | "bzip2" }?
buildnumber = element buildnumber { attlist.buildnumber, empty }
attlist.buildnumber &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?
p4have = element p4have { attlist.p4have, empty }
attlist.p4have &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?
record = element record { attlist.record, empty }
attlist.record &=
  attribute id { xsd:ID }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute name { text }?,
  attribute loglevel {
    "error" | "warn" | "warning" | "info" | "verbose" | "debug"
  }?,
  attribute description { text }?,
  attribute emacsmode { boolean }?,
  attribute action { "start" | "stop" }?
vsscp = element vsscp { attlist.vsscp, empty }
attlist.vsscp &=
  attribute id { xsd:ID }?,
  attribute login { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute vsspath { text }?,
  attribute serverpath { text }?,
  attribute ssdir { text }?,
  attribute autoresponse { text }?,
  attribute failonerror { boolean }?
truncate = element truncate { attlist.truncate, empty }
attlist.truncate &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute create { boolean }?,
  attribute mkdirs { boolean }?,
  attribute description { text }?,
  attribute length { text }?,
  attribute adjust { text }?
tar =
  element tar {
    attlist.tar,
    (patternset
     | exclude
     | \include
     | tarfileset
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.tar &=
  attribute id { xsd:ID }?,
  attribute tarfile { text }?,
  attribute destfile { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute basedir { text }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute includesfile { text }?,
  attribute excludes { text }?,
  attribute compression { "none" | "gzip" | "bzip2" }?,
  attribute longfile { "warn" | "fail" | "truncate" | "gnu" | "omit" }?,
  attribute includes { text }?
jarlib-display =
  element jarlib-display { attlist.jarlib-display, fileset* }
attlist.jarlib-display &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute file { text }?,
  attribute description { text }?
chmod =
  element chmod {
    attlist.chmod,
    (mapper
     | \include
     | srcfile
     | exclude
     | targetfile
     | patternset
     | redirector
     | env
     | filelist
     | fileset
     | dirset
     | arg)*
  }
attlist.chmod &=
  attribute id { xsd:ID }?,
  attribute addsourcefile { boolean }?,
  attribute excludes { text }?,
  attribute verbose { boolean }?,
  attribute parallel { boolean }?,
  attribute input { text }?,
  attribute executable { text }?,
  attribute force { boolean }?,
  attribute inputstring { text }?,
  attribute osfamily { text }?,
  attribute searchpath { boolean }?,
  attribute relative { boolean }?,
  attribute skipemptyfilesets { boolean }?,
  attribute command { text }?,
  attribute forwardslash { boolean }?,
  attribute spawn { boolean }?,
  attribute description { text }?,
  attribute includes { text }?,
  attribute vmlauncher { boolean }?,
  attribute file { text }?,
  attribute logerror { boolean }?,
  attribute errorproperty { text }?,
  attribute failonerror { boolean }?,
  attribute output { text }?,
  attribute error { text }?,
  attribute defaultexcludes { boolean }?,
  attribute os { text }?,
  attribute dest { text }?,
  attribute resolveexecutable { boolean }?,
  attribute taskname { text }?,
  attribute resultproperty { text }?,
  attribute ignoremissing { boolean }?,
  attribute failifexecutionfails { boolean }?,
  attribute append { boolean }?,
  attribute timeout { text }?,
  attribute maxparallel { text }?,
  attribute outputproperty { text }?,
  attribute perm { text }?,
  attribute dir { text }?,
  attribute newenvironment { boolean }?,
  attribute type { "file" | "dir" | "both" }?
replaceregexp =
  element replaceregexp {
    attlist.replaceregexp, (fileset | substitution | regexp)*
  }
attlist.replaceregexp &=
  attribute id { xsd:ID }?,
  attribute encoding { text }?,
  attribute replace { text }?,
  attribute flags { text }?,
  attribute file { text }?,
  attribute match { text }?,
  attribute byline { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute preservelastmodified { boolean }?
native2ascii =
  element native2ascii {
    attlist.native2ascii,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | arg
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | mapper
     | date
     | excludesfile
     | implementationclasspath
     | and
     | depth)*
  }
attlist.native2ascii &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute encoding { text }?,
  attribute ext { text }?,
  attribute implementation { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute reverse { boolean }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute dest { text }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute includesfile { text }?,
  attribute excludes { text }?,
  attribute includes { text }?
serverdeploy =
  element serverdeploy {
    attlist.serverdeploy, (weblogic | generic | jonas)*
  }
attlist.serverdeploy &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute action { text }?,
  attribute source { text }?
weblogic = element weblogic { attlist.weblogic, classpath* }
attlist.weblogic &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute debug { boolean }?,
  attribute password { text }?,
  attribute component { text }?,
  attribute application { text }?,
  attribute server { text }?,
  attribute username { text }?
generic =
  element generic { attlist.generic, (arg | classpath | jvmarg)* }
attlist.generic &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute password { text }?,
  attribute server { text }?,
  attribute classname { text }?,
  attribute username { text }?
jonas = element jonas { attlist.jonas, (arg | classpath | jvmarg)* }
attlist.jonas &=
  attribute id { xsd:ID }?,
  attribute jonasroot { text }?,
  attribute orb { text }?,
  attribute classpath { text }?,
  attribute davidhost { text }?,
  attribute classname { text }?,
  attribute server { text }?,
  attribute username { text }?,
  attribute davidport { text }?,
  attribute password { text }?
wljspc =
  element wljspc {
    attlist.wljspc,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | classpath
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.wljspc &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute classpath { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute dest { text }?,
  attribute package { text }?,
  attribute description { text }?,
  attribute excludesfile { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute includes { text }?
delete =
  element delete {
    attlist.delete,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | fileset
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.delete &=
  attribute id { xsd:ID }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute quiet { boolean }?,
  attribute verbose { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute includeemptydirs { boolean }?,
  attribute removenotfollowedsymlinks { boolean }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute deleteonexit { boolean }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute includes { text }?
length = element length { attlist.length, empty }
attlist.length &=
  attribute id { xsd:ID }?,
  attribute length { text }?,
  attribute file { text }?,
  attribute trim { boolean }?,
  attribute resource { text }?,
  attribute mode { "each" | "all" }?,
  attribute string { text }?,
  attribute when {
    "equal"
    | "greater"
    | "less"
    | "ne"
    | "ge"
    | "le"
    | "eq"
    | "gt"
    | "lt"
    | "more"
  }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute property { text }?
cvs = element cvs { attlist.cvs, (module | commandline)* }
attlist.cvs &=
  attribute id { xsd:ID }?,
  attribute cvsrsh { text }?,
  attribute quiet { boolean }?,
  attribute passfile { text }?,
  attribute command { text }?,
  attribute package { text }?,
  attribute cvsroot { text }?,
  attribute reallyquiet { boolean }?,
  attribute output { text }?,
  attribute port { text }?,
  attribute dest { text }?,
  attribute compressionlevel { text }?,
  attribute noexec { boolean }?,
  attribute error { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute date { text }?,
  attribute compression { boolean }?,
  attribute tag { text }?
vsslabel = element vsslabel { attlist.vsslabel, empty }
attlist.vsslabel &=
  attribute id { xsd:ID }?,
  attribute ssdir { text }?,
  attribute autoresponse { text }?,
  attribute vsspath { text }?,
  attribute comment { text }?,
  attribute version { text }?,
  attribute serverpath { text }?,
  attribute login { text }?,
  attribute taskname { text }?,
  attribute label { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?
apt =
  element apt {
    attlist.apt,
    (patternset
     | exclude
     | \include
     | custom
     | present
     | none
     | extdirs
     | not
     | type
     | compilerclasspath
     | modified
     | src
     | or
     | contains
     | depend
     | classpath
     | sourcepath
     | option
     | different
     | size
     | majority
     | containsregexp
     | bootclasspath
     | filename
     | selector
     | includesfile
     | compilerarg
     | date
     | excludesfile
     | factorypath
     | depth
     | and)*
  }
attlist.apt &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute target { text }?,
  attribute verbose { boolean }?,
  attribute bootclasspathref { xsd:IDREF }?,
  attribute compiler { text }?,
  attribute executable { text }?,
  attribute debuglevel { text }?,
  attribute memoryinitialsize { text }?,
  attribute deprecation { boolean }?,
  attribute compile { boolean }?,
  attribute includeantruntime { boolean }?,
  attribute description { text }?,
  attribute sourcepathref { xsd:IDREF }?,
  attribute depend { boolean }?,
  attribute includes { text }?,
  attribute source { text }?,
  attribute includejavaruntime { boolean }?,
  attribute errorproperty { text }?,
  attribute failonerror { boolean }?,
  attribute destdir { text }?,
  attribute debug { boolean }?,
  attribute factory { text }?,
  attribute tempdir { text }?,
  attribute classpath { text }?,
  attribute factorypathref { xsd:IDREF }?,
  attribute followsymlinks { boolean }?,
  attribute casesensitive { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute bootclasspath { text }?,
  attribute includedestclasses { boolean }?,
  attribute preprocessdir { text }?,
  attribute includesfile { text }?,
  attribute updatedproperty { text }?,
  attribute nowarn { boolean }?,
  attribute proceed { boolean }?,
  attribute taskname { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute fork { boolean }?,
  attribute srcdir { text }?,
  attribute memorymaximumsize { text }?,
  attribute optimize { boolean }?,
  attribute encoding { text }?,
  attribute excludesfile { text }?,
  attribute sourcepath { text }?,
  attribute listfiles { boolean }?,
  attribute extdirs { text }?
option = element option { attlist.option, empty }
attlist.option &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute value { text }?
factorypath =
  element factorypath {
    attlist.factorypath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.factorypath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
genkey = element genkey { attlist.genkey, dname* }
attlist.genkey &=
  attribute id { xsd:ID }?,
  attribute storepass { text }?,
  attribute sigalg { text }?,
  attribute verbose { boolean }?,
  attribute keypass { text }?,
  attribute dname { text }?,
  attribute keysize { text }?,
  attribute alias { text }?,
  attribute keyalg { text }?,
  attribute validity { text }?,
  attribute keystore { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute storetype { text }?
dname = element dname { attlist.dname, param* }
attlist.dname &= attribute id { xsd:ID }?
copyfile = element copyfile { attlist.copyfile, empty }
attlist.copyfile &=
  attribute id { xsd:ID }?,
  attribute forceoverwrite { boolean }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?,
  attribute filtering { text }?,
  attribute src { text }?
mkdir = element mkdir { attlist.mkdir, empty }
attlist.mkdir &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute dir { text }?,
  attribute description { text }?
execon =
  element execon {
    attlist.execon,
    (mapper
     | srcfile
     | targetfile
     | redirector
     | env
     | filelist
     | fileset
     | dirset
     | arg)*
  }
attlist.execon &=
  attribute id { xsd:ID }?,
  attribute resultproperty { text }?,
  attribute skipemptyfilesets { boolean }?,
  attribute force { boolean }?,
  attribute command { text }?,
  attribute failifexecutionfails { boolean }?,
  attribute type { "file" | "dir" | "both" }?,
  attribute maxparallel { text }?,
  attribute executable { text }?,
  attribute osfamily { text }?,
  attribute os { text }?,
  attribute errorproperty { text }?,
  attribute output { text }?,
  attribute timeout { text }?,
  attribute dest { text }?,
  attribute spawn { boolean }?,
  attribute input { text }?,
  attribute inputstring { text }?,
  attribute addsourcefile { boolean }?,
  attribute verbose { boolean }?,
  attribute searchpath { boolean }?,
  attribute logerror { boolean }?,
  attribute dir { text }?,
  attribute forwardslash { boolean }?,
  attribute error { text }?,
  attribute description { text }?,
  attribute outputproperty { text }?,
  attribute resolveexecutable { boolean }?,
  attribute failonerror { boolean }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute ignoremissing { boolean }?,
  attribute newenvironment { boolean }?,
  attribute vmlauncher { boolean }?,
  attribute relative { boolean }?,
  attribute parallel { boolean }?
sql =
  element sql {
    attlist.sql,
    (text | fileset | classpath | connectionproperty | transaction)*
  }
attlist.sql &=
  attribute id { xsd:ID }?,
  attribute showwarnings { boolean }?,
  attribute onerror { "continue" | "stop" | "abort" }?,
  attribute userid { text }?,
  attribute password { text }?,
  attribute autocommit { boolean }?,
  attribute rdbms { text }?,
  attribute csvquotecharacter { text }?,
  attribute print { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute encoding { text }?,
  attribute version { text }?,
  attribute url { text }?,
  attribute rowcountproperty { text }?,
  attribute treatwarningsaserrors { boolean }?,
  attribute warningproperty { text }?,
  attribute src { text }?,
  attribute errorproperty { text }?,
  attribute showtrailers { boolean }?,
  attribute output { text }?,
  attribute driver { text }?,
  attribute strictdelimitermatching { boolean }?,
  attribute classpath { text }?,
  attribute showheaders { boolean }?,
  attribute failonconnectionerror { boolean }?,
  attribute delimitertype { "normal" | "row" }?,
  attribute escapeprocessing { boolean }?,
  attribute rawblobs { boolean }?,
  attribute description { text }?,
  attribute expandproperties { boolean }?,
  attribute append { boolean }?,
  attribute csvcolumnseparator { text }?,
  attribute taskname { text }?,
  attribute caching { boolean }?,
  attribute keepformat { boolean }?,
  attribute delimiter { text }?
connectionproperty =
  element connectionproperty {
    attlist.connectionproperty, (text | classpath)*
  }
attlist.connectionproperty &=
  attribute id { xsd:ID }?,
  attribute prefixvalues { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute name { text }?,
  attribute relative { boolean }?,
  attribute url { text }?,
  attribute classpath { text }?,
  attribute file { text }?,
  attribute userproperty { boolean }?,
  attribute resource { text }?,
  attribute environment { text }?,
  attribute prefix { text }?,
  attribute basedir { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute location { text }?,
  attribute value { text }?,
  attribute description { text }?
transaction = element transaction { attlist.transaction, text }
attlist.transaction &=
  attribute id { xsd:ID }?,
  attribute srcresource { text }?,
  attribute src { text }?
translate =
  element translate {
    attlist.translate,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | fileset
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.translate &=
  attribute id { xsd:ID }?,
  attribute bundlecountry { text }?,
  attribute bundlelanguage { text }?,
  attribute excludes { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute srcencoding { text }?,
  attribute bundle { text }?,
  attribute bundleencoding { text }?,
  attribute casesensitive { boolean }?,
  attribute destencoding { text }?,
  attribute bundlevariant { text }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute todir { text }?,
  attribute includesfile { text }?,
  attribute taskname { text }?,
  attribute excludesfile { text }?,
  attribute endtoken { text }?,
  attribute forceoverwrite { boolean }?,
  attribute starttoken { text }?
cccheckin = element cccheckin { attlist.cccheckin, empty }
attlist.cccheckin &=
  attribute id { xsd:ID }?,
  attribute preservetime { boolean }?,
  attribute viewpath { text }?,
  attribute comment { text }?,
  attribute nowarn { boolean }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute identical { boolean }?,
  attribute cleartooldir { text }?,
  attribute taskname { text }?,
  attribute keepcopy { boolean }?,
  attribute description { text }?,
  attribute commentfile { text }?
retry = element retry { attlist.retry, tasks* }
attlist.retry &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute retrycount { text }?,
  attribute description { text }?
vsshistory = element vsshistory { attlist.vsshistory, empty }
attlist.vsshistory &=
  attribute id { xsd:ID }?,
  attribute style { "brief" | "codediff" | "nofile" | "default" }?,
  attribute numdays { text }?,
  attribute todate { text }?,
  attribute fromlabel { text }?,
  attribute output { text }?,
  attribute ssdir { text }?,
  attribute recursive { boolean }?,
  attribute vsspath { text }?,
  attribute fromdate { text }?,
  attribute user { text }?,
  attribute serverpath { text }?,
  attribute login { text }?,
  attribute taskname { text }?,
  attribute tolabel { text }?,
  attribute dateformat { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?
patch = element patch { attlist.patch, empty }
attlist.patch &=
  attribute id { xsd:ID }?,
  attribute strip { text }?,
  attribute dir { text }?,
  attribute destfile { text }?,
  attribute quiet { boolean }?,
  attribute originalfile { text }?,
  attribute patchfile { text }?,
  attribute reverse { boolean }?,
  attribute taskname { text }?,
  attribute backups { boolean }?,
  attribute ignorewhitespace { boolean }?,
  attribute description { text }?,
  attribute failonerror { boolean }?
jjtree = element jjtree { attlist.jjtree, empty }
attlist.jjtree &=
  attribute id { xsd:ID }?,
  attribute nodedefaultvoid { boolean }?,
  attribute buildnodefiles { boolean }?,
  attribute outputdirectory { text }?,
  attribute outputfile { text }?,
  attribute static { boolean }?,
  attribute javacchome { text }?,
  attribute nodeprefix { text }?,
  attribute nodefactory { boolean }?,
  attribute multi { boolean }?,
  attribute visitor { boolean }?,
  attribute target { text }?,
  attribute nodeusesparser { boolean }?,
  attribute visitorexception { text }?,
  attribute nodescopehook { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute nodepackage { text }?
ccmkdir = element ccmkdir { attlist.ccmkdir, empty }
attlist.ccmkdir &=
  attribute id { xsd:ID }?,
  attribute viewpath { text }?,
  attribute comment { text }?,
  attribute failonerr { boolean }?,
  attribute cleartooldir { text }?,
  attribute objselect { text }?,
  attribute nocheckout { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute commentfile { text }?
apply =
  element apply {
    attlist.apply,
    (mapper
     | srcfile
     | targetfile
     | redirector
     | env
     | filelist
     | fileset
     | dirset
     | arg)*
  }
attlist.apply &=
  attribute id { xsd:ID }?,
  attribute resultproperty { text }?,
  attribute skipemptyfilesets { boolean }?,
  attribute force { boolean }?,
  attribute command { text }?,
  attribute failifexecutionfails { boolean }?,
  attribute type { "file" | "dir" | "both" }?,
  attribute maxparallel { text }?,
  attribute executable { text }?,
  attribute osfamily { text }?,
  attribute os { text }?,
  attribute errorproperty { text }?,
  attribute output { text }?,
  attribute timeout { text }?,
  attribute dest { text }?,
  attribute spawn { boolean }?,
  attribute input { text }?,
  attribute inputstring { text }?,
  attribute addsourcefile { boolean }?,
  attribute verbose { boolean }?,
  attribute searchpath { boolean }?,
  attribute logerror { boolean }?,
  attribute dir { text }?,
  attribute forwardslash { boolean }?,
  attribute error { text }?,
  attribute description { text }?,
  attribute outputproperty { text }?,
  attribute resolveexecutable { boolean }?,
  attribute failonerror { boolean }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute ignoremissing { boolean }?,
  attribute newenvironment { boolean }?,
  attribute vmlauncher { boolean }?,
  attribute relative { boolean }?,
  attribute parallel { boolean }?
unjar =
  element unjar { attlist.unjar, (fileset | patternset | mapper)* }
attlist.unjar &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute encoding { text }?,
  attribute failonemptyarchive { boolean }?,
  attribute overwrite { boolean }?,
  attribute scanforunicodeextrafields { boolean }?,
  attribute stripabsolutepathspec { boolean }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?
antstructure = element antstructure { attlist.antstructure, empty }
attlist.antstructure &=
  attribute id { xsd:ID }?,
  attribute output { text }?,
  attribute taskname { text }?,
  attribute description { text }?
rename = element rename { attlist.rename, empty }
attlist.rename &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute replace { text }?,
  attribute description { text }?,
  attribute src { text }?
signjar =
  element signjar { attlist.signjar, (fileset | sysproperty | path)* }
attlist.signjar &=
  attribute id { xsd:ID }?,
  attribute keystore { text }?,
  attribute force { boolean }?,
  attribute keypass { text }?,
  attribute maxmemory { text }?,
  attribute jar { text }?,
  attribute destdir { text }?,
  attribute executable { text }?,
  attribute internalsf { boolean }?,
  attribute sigfile { text }?,
  attribute tsacert { text }?,
  attribute storepass { text }?,
  attribute signedjar { text }?,
  attribute verbose { boolean }?,
  attribute storetype { text }?,
  attribute alias { text }?,
  attribute lazy { boolean }?,
  attribute description { text }?,
  attribute sectionsonly { boolean }?,
  attribute taskname { text }?,
  attribute tsaurl { text }?,
  attribute preservelastmodified { boolean }?
vssget = element vssget { attlist.vssget, empty }
attlist.vssget &=
  attribute id { xsd:ID }?,
  attribute ssdir { text }?,
  attribute date { text }?,
  attribute recursive { boolean }?,
  attribute autoresponse { text }?,
  attribute quiet { boolean }?,
  attribute vsspath { text }?,
  attribute version { text }?,
  attribute serverpath { text }?,
  attribute login { text }?,
  attribute writable { boolean }?,
  attribute filetimestamp { "current" | "modified" | "updated" }?,
  attribute taskname { text }?,
  attribute label { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute localpath { text }?,
  attribute writablefiles { "replace" | "skip" | "fail" }?
bindtargets = element bindtargets { attlist.bindtargets, empty }
attlist.bindtargets &=
  attribute id { xsd:ID }?,
  attribute targets { text }?,
  attribute taskname { text }?,
  attribute extensionpoint { text }?,
  attribute onmissingextensionpoint { text }?,
  attribute description { text }?
antversion = element antversion { attlist.antversion, empty }
attlist.antversion &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute exactly { text }?,
  attribute property { text }?,
  attribute atleast { text }?
macrodef =
  element macrodef {
    attlist.macrodef, (sequential | \element | \attribute | \text)*
  }
attlist.macrodef &=
  attribute id { xsd:ID }?,
  attribute backtrace { boolean }?,
  attribute taskname { text }?,
  attribute name { text }?,
  attribute description { text }?,
  attribute uri { text }?
\text = element text { attlist.text, empty }
attlist.text &=
  attribute id { xsd:ID }?,
  attribute trim { boolean }?,
  attribute default { text }?,
  attribute name { text }?,
  attribute optional { boolean }?,
  attribute description { text }?
xmlproperty = element xmlproperty { attlist.xmlproperty, xmlcatalog* }
attlist.xmlproperty &=
  attribute id { xsd:ID }?,
  attribute delimiter { text }?,
  attribute file { text }?,
  attribute semanticattributes { boolean }?,
  attribute keeproot { boolean }?,
  attribute prefix { text }?,
  attribute collapseattributes { boolean }?,
  attribute validate { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute srcresource { text }?,
  attribute rootdirectory { text }?,
  attribute includesemanticattribute { boolean }?
resourcecount = element resourcecount { attlist.resourcecount, empty }
attlist.resourcecount &=
  attribute id { xsd:ID }?,
  attribute when {
    "equal"
    | "greater"
    | "less"
    | "ne"
    | "ge"
    | "le"
    | "eq"
    | "gt"
    | "lt"
    | "more"
  }?,
  attribute taskname { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute count { text }?,
  attribute property { text }?
ccuncheckout = element ccuncheckout { attlist.ccuncheckout, empty }
attlist.ccuncheckout &=
  attribute id { xsd:ID }?,
  attribute objselect { text }?,
  attribute keepcopy { boolean }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute cleartooldir { text }?,
  attribute viewpath { text }?,
  attribute failonerr { boolean }?
p4edit = element p4edit { attlist.p4edit, empty }
attlist.p4edit &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute change { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?
loadproperties =
  element loadproperties {
    attlist.loadproperties, (filterchain | classpath)*
  }
attlist.loadproperties &=
  attribute id { xsd:ID }?,
  attribute prefixvalues { boolean }?,
  attribute srcfile { text }?,
  attribute encoding { text }?,
  attribute classpath { text }?,
  attribute resource { text }?,
  attribute prefix { text }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute description { text }?
gzip = element gzip { attlist.gzip, empty }
attlist.gzip &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute zipfile { text }?,
  attribute description { text }?,
  attribute srcresource { text }?,
  attribute src { text }?,
  attribute destfile { text }?
ccmreconfigure =
  element ccmreconfigure { attlist.ccmreconfigure, empty }
attlist.ccmreconfigure &=
  attribute id { xsd:ID }?,
  attribute ccmaction { text }?,
  attribute verbose { boolean }?,
  attribute taskname { text }?,
  attribute ccmproject { text }?,
  attribute description { text }?,
  attribute recurse { boolean }?,
  attribute ccmdir { text }?
antlr = element antlr { attlist.antlr, (jvmarg | classpath)* }
attlist.antlr &=
  attribute id { xsd:ID }?,
  attribute debug { boolean }?,
  attribute outputdirectory { text }?,
  attribute fork { boolean }?,
  attribute dir { text }?,
  attribute trace { boolean }?,
  attribute tracetreewalker { boolean }?,
  attribute html { boolean }?,
  attribute tracelexer { boolean }?,
  attribute diagnostic { boolean }?,
  attribute traceparser { boolean }?,
  attribute target { text }?,
  attribute taskname { text }?,
  attribute glib { text }?,
  attribute description { text }?
ccupdate = element ccupdate { attlist.ccupdate, empty }
attlist.ccupdate &=
  attribute id { xsd:ID }?,
  attribute preservetime { boolean }?,
  attribute rename { boolean }?,
  attribute viewpath { text }?,
  attribute log { text }?,
  attribute overwrite { boolean }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute cleartooldir { text }?,
  attribute graphical { boolean }?,
  attribute taskname { text }?,
  attribute currenttime { boolean }?,
  attribute description { text }?
p4label = element p4label { attlist.p4label, empty }
attlist.p4label &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute desc { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?,
  attribute lock { text }?
unzip =
  element unzip { attlist.unzip, (fileset | patternset | mapper)* }
attlist.unzip &=
  attribute id { xsd:ID }?,
  attribute src { text }?,
  attribute encoding { text }?,
  attribute failonemptyarchive { boolean }?,
  attribute overwrite { boolean }?,
  attribute scanforunicodeextrafields { boolean }?,
  attribute stripabsolutepathspec { boolean }?,
  attribute taskname { text }?,
  attribute dest { text }?,
  attribute description { text }?
presetdef = element presetdef { attlist.presetdef, tasks* }
attlist.presetdef &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute name { text }?,
  attribute description { text }?,
  attribute uri { text }?
fixcrlf =
  element fixcrlf {
    attlist.fixcrlf,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.fixcrlf &=
  attribute id { xsd:ID }?,
  attribute tab { "add" | "asis" | "remove" }?,
  attribute excludes { text }?,
  attribute encoding { text }?,
  attribute cr { "add" | "asis" | "remove" }?,
  attribute destdir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute eol {
    "asis" | "cr" | "lf" | "crlf" | "mac" | "unix" | "dos"
  }?,
  attribute followsymlinks { boolean }?,
  attribute javafiles { boolean }?,
  attribute eof { "add" | "asis" | "remove" }?,
  attribute casesensitive { boolean }?,
  attribute tablength { text }?,
  attribute outputencoding { text }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute fixlast { boolean }?,
  attribute includesfile { text }?,
  attribute taskname { text }?,
  attribute srcdir { text }?,
  attribute file { text }?,
  attribute excludesfile { text }?,
  attribute preservelastmodified { boolean }?
schemavalidate =
  element schemavalidate {
    attlist.schemavalidate,
    (fileset
     | classpath
     | \attribute
     | dtd
     | xmlcatalog
     | schema
     | property)*
  }
attlist.schemavalidate &=
  attribute id { xsd:ID }?,
  attribute fullchecking { boolean }?,
  attribute classpath { text }?,
  attribute file { text }?,
  attribute classname { text }?,
  attribute lenient { boolean }?,
  attribute warn { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute nonamespacefile { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute disabledtd { boolean }?,
  attribute nonamespaceurl { text }?
schema = element schema { attlist.schema, empty }
attlist.schema &=
  attribute id { xsd:ID }?,
  attribute url { text }?,
  attribute file { text }?,
  attribute namespace { text }?
war =
  element war {
    attlist.war,
    (patternset
     | exclude
     | \include
     | custom
     | present
     | none
     | not
     | manifest
     | type
     | metainf
     | modified
     | or
     | contains
     | depend
     | lib
     | fileset
     | different
     | size
     | majority
     | containsregexp
     | indexjars
     | filename
     | selector
     | includesfile
     | zipgroupfileset
     | zipfileset
     | classes
     | date
     | excludesfile
     | webinf
     | depth
     | and
     | service)*
  }
attlist.war &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute manifestencoding { text }?,
  attribute destfile { text }?,
  attribute indexmetainf { boolean }?,
  attribute level { text }?,
  attribute zipfile { text }?,
  attribute basedir { text }?,
  attribute manifest { text }?,
  attribute needxmlfile { boolean }?,
  attribute description { text }?,
  attribute includes { text }?,
  attribute keepcompression { boolean }?,
  attribute webxml { text }?,
  attribute file { text }?,
  attribute whenmanifestonly { "fail" | "skip" | "create" }?,
  attribute duplicate { "add" | "preserve" | "fail" }?,
  attribute followsymlinks { boolean }?,
  attribute casesensitive { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute jarfile { text }?,
  attribute warfile { text }?,
  attribute uselanguageencodingflag { boolean }?,
  attribute createunicodeextrafields {
    "never" | "always" | "not-encodeable"
  }?,
  attribute flattenattributes { boolean }?,
  attribute index { boolean }?,
  attribute includesfile { text }?,
  attribute update { boolean }?,
  attribute comment { text }?,
  attribute fallbacktoutf8 { boolean }?,
  attribute taskname { text }?,
  attribute strict { "fail" | "warn" | "ignore" }?,
  attribute roundup { boolean }?,
  attribute encoding { text }?,
  attribute excludesfile { text }?,
  attribute whenempty { "fail" | "skip" | "create" }?,
  attribute filesonly { boolean }?,
  attribute filesetmanifest { "skip" | "merge" | "mergewithoutmain" }?,
  attribute mergeclasspathattributes { boolean }?,
  attribute compress { boolean }?,
  attribute preserve0permissions { boolean }?
lib =
  element lib {
    attlist.lib,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.lib &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute encoding { text }?,
  attribute filemode { text }?,
  attribute defaultexcludes { boolean }?,
  attribute src { text }?,
  attribute srcresource { text }?,
  attribute fullpath { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute erroronmissingarchive { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute casesensitive { boolean }?,
  attribute dir { text }?,
  attribute erroronmissingdir { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute prefix { text }?,
  attribute dirmode { text }?,
  attribute includesfile { text }?,
  attribute file { text }?,
  attribute excludesfile { text }?
classes =
  element classes {
    attlist.classes,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.classes &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute encoding { text }?,
  attribute filemode { text }?,
  attribute defaultexcludes { boolean }?,
  attribute src { text }?,
  attribute srcresource { text }?,
  attribute fullpath { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute erroronmissingarchive { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute casesensitive { boolean }?,
  attribute dir { text }?,
  attribute erroronmissingdir { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute prefix { text }?,
  attribute dirmode { text }?,
  attribute includesfile { text }?,
  attribute file { text }?,
  attribute excludesfile { text }?
webinf =
  element webinf {
    attlist.webinf,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.webinf &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute encoding { text }?,
  attribute filemode { text }?,
  attribute defaultexcludes { boolean }?,
  attribute src { text }?,
  attribute srcresource { text }?,
  attribute fullpath { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute erroronmissingarchive { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute casesensitive { boolean }?,
  attribute dir { text }?,
  attribute erroronmissingdir { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute prefix { text }?,
  attribute dirmode { text }?,
  attribute includesfile { text }?,
  attribute file { text }?,
  attribute excludesfile { text }?
netrexxc =
  element netrexxc {
    attlist.netrexxc,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.netrexxc &=
  attribute id { xsd:ID }?,
  attribute excludes { text }?,
  attribute verbose {
    "verbose"
    | "verbose0"
    | "verbose1"
    | "verbose2"
    | "verbose3"
    | "verbose4"
    | "verbose5"
    | "noverbose"
  }?,
  attribute keep { boolean }?,
  attribute comments { boolean }?,
  attribute strictimport { boolean }?,
  attribute sourcedir { boolean }?,
  attribute diag { boolean }?,
  attribute compile { boolean }?,
  attribute binary { boolean }?,
  attribute description { text }?,
  attribute includes { text }?,
  attribute suppressmethodargumentnotused { boolean }?,
  attribute suppressvariablenotused { boolean }?,
  attribute strictsignal { boolean }?,
  attribute trace { "trace" | "trace1" | "trace2" | "notrace" }?,
  attribute destdir { text }?,
  attribute console { boolean }?,
  attribute replace { boolean }?,
  attribute classpath { text }?,
  attribute followsymlinks { boolean }?,
  attribute casesensitive { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute format { boolean }?,
  attribute explicit { boolean }?,
  attribute includesfile { text }?,
  attribute suppressprivatepropertynotused { boolean }?,
  attribute strictargs { boolean }?,
  attribute removekeepextension { boolean }?,
  attribute suppressdeprecation { boolean }?,
  attribute strictcase { boolean }?,
  attribute taskname { text }?,
  attribute savelog { boolean }?,
  attribute logo { boolean }?,
  attribute utf8 { boolean }?,
  attribute strictprops { boolean }?,
  attribute srcdir { text }?,
  attribute java { boolean }?,
  attribute suppressexceptionnotsignalled { boolean }?,
  attribute crossref { boolean }?,
  attribute time { boolean }?,
  attribute symbols { boolean }?,
  attribute excludesfile { text }?,
  attribute strictassign { boolean }?,
  attribute compact { boolean }?,
  attribute decimal { boolean }?
ccrmtype = element ccrmtype { attlist.ccrmtype, empty }
attlist.ccrmtype &=
  attribute id { xsd:ID }?,
  attribute viewpath { text }?,
  attribute typename { text }?,
  attribute rmall { boolean }?,
  attribute comment { text }?,
  attribute ignore { boolean }?,
  attribute typekind { text }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute cleartooldir { text }?,
  attribute taskname { text }?,
  attribute vob { text }?,
  attribute description { text }?,
  attribute commentfile { text }?
copypath = element copypath { attlist.copypath, path* }
attlist.copypath &=
  attribute id { xsd:ID }?,
  attribute destdir { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute pathref { xsd:IDREF }?,
  attribute preservelastmodified { boolean }?,
  attribute path { text }?,
  attribute granularity { text }?
xmlvalidate =
  element xmlvalidate {
    attlist.xmlvalidate,
    (fileset | classpath | \attribute | dtd | xmlcatalog | property)*
  }
attlist.xmlvalidate &=
  attribute id { xsd:ID }?,
  attribute classpath { text }?,
  attribute file { text }?,
  attribute classname { text }?,
  attribute lenient { boolean }?,
  attribute warn { boolean }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?
zip =
  element zip {
    attlist.zip,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | modified
     | or
     | contains
     | depend
     | fileset
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | zipgroupfileset
     | zipfileset
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.zip &=
  attribute id { xsd:ID }?,
  attribute level { text }?,
  attribute comment { text }?,
  attribute whenempty { "fail" | "skip" | "create" }?,
  attribute keepcompression { boolean }?,
  attribute duplicate { "add" | "preserve" | "fail" }?,
  attribute roundup { boolean }?,
  attribute excludes { text }?,
  attribute basedir { text }?,
  attribute encoding { text }?,
  attribute defaultexcludes { boolean }?,
  attribute update { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute destfile { text }?,
  attribute uselanguageencodingflag { boolean }?,
  attribute casesensitive { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute includesfile { text }?,
  attribute compress { boolean }?,
  attribute taskname { text }?,
  attribute fallbacktoutf8 { boolean }?,
  attribute filesonly { boolean }?,
  attribute preserve0permissions { boolean }?,
  attribute file { text }?,
  attribute excludesfile { text }?,
  attribute createunicodeextrafields {
    "never" | "always" | "not-encodeable"
  }?,
  attribute zipfile { text }?
pvcs = element pvcs { attlist.pvcs, pvcsproject* }
attlist.pvcs &=
  attribute id { xsd:ID }?,
  attribute updateonly { boolean }?,
  attribute force { text }?,
  attribute config { text }?,
  attribute workspace { text }?,
  attribute pvcsbin { text }?,
  attribute pvcsproject { text }?,
  attribute filenameformat { text }?,
  attribute userid { text }?,
  attribute repository { text }?,
  attribute ignorereturncode { boolean }?,
  attribute revision { text }?,
  attribute linestart { text }?,
  attribute taskname { text }?,
  attribute label { text }?,
  attribute promotiongroup { text }?,
  attribute description { text }?
pvcsproject = element pvcsproject { attlist.pvcsproject, empty }
attlist.pvcsproject &=
  attribute id { xsd:ID }?,
  attribute name { text }?
ejbjar =
  element ejbjar {
    attlist.ejbjar,
    (patternset
     | exclude
     | \include
     | custom
     | weblogictoplink
     | present
     | none
     | jboss
     | borland
     | weblogic
     | not
     | type
     | modified
     | iplanet
     | jonas
     | or
     | contains
     | depend
     | support
     | classpath
     | different
     | size
     | majority
     | websphere
     | containsregexp
     | dtd
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | depth
     | and)*
  }
attlist.ejbjar &=
  attribute id { xsd:ID }?,
  attribute descriptordir { text }?,
  attribute excludes { text }?,
  attribute manifest { text }?,
  attribute destdir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute basenameterminator { text }?,
  attribute classpath { text }?,
  attribute casesensitive { boolean }?,
  attribute cmpversion { "1.0" | "2.0" }?,
  attribute dependency { text }?,
  attribute basejarname { text }?,
  attribute flatdestdir { boolean }?,
  attribute includes { text }?,
  attribute description { text }?,
  attribute includesfile { text }?,
  attribute taskname { text }?,
  attribute srcdir { text }?,
  attribute naming {
    "ejb-name" | "directory" | "descriptor" | "basejarname"
  }?,
  attribute excludesfile { text }?,
  attribute genericjarsuffix { text }?
weblogictoplink =
  element weblogictoplink {
    attlist.weblogictoplink, (classpath | wlclasspath | sysproperty)*
  }
attlist.weblogictoplink &=
  attribute id { xsd:ID }?,
  attribute newcmp { boolean }?,
  attribute ejbdtd { text }?,
  attribute jvmargs { text }?,
  attribute rebuild { boolean }?,
  attribute suffix { text }?,
  attribute args { text }?,
  attribute outputdir { text }?,
  attribute toplinkdtd { text }?,
  attribute wldtd { text }?,
  attribute destdir { text }?,
  attribute weblogicdtd { text }?,
  attribute wlclasspath { text }?,
  attribute jvmdebuglevel { text }?,
  attribute classpath { text }?,
  attribute keepgenerated { text }?,
  attribute compiler { text }?,
  attribute oldcmp { boolean }?,
  attribute keepgeneric { boolean }?,
  attribute ejbcclass { text }?,
  attribute noejbc { boolean }?,
  attribute toplinkdescriptor { text }?,
  attribute genericjarsuffix { text }?
wlclasspath =
  element wlclasspath {
    attlist.wlclasspath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.wlclasspath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
jboss = element jboss { attlist.jboss, classpath* }
attlist.jboss &=
  attribute id { xsd:ID }?,
  attribute destdir { text }?,
  attribute genericjarsuffix { text }?,
  attribute classpath { text }?,
  attribute suffix { text }?
borland = element borland { attlist.borland, classpath* }
attlist.borland &=
  attribute id { xsd:ID }?,
  attribute verifyargs { text }?,
  attribute debug { boolean }?,
  attribute destdir { text }?,
  attribute classpath { text }?,
  attribute genericjarsuffix { text }?,
  attribute java2iiopparams { text }?,
  attribute version { text }?,
  attribute basdtd { text }?,
  attribute verify { boolean }?,
  attribute suffix { text }?,
  attribute generateclient { boolean }?
iplanet = element iplanet { attlist.iplanet, classpath* }
attlist.iplanet &=
  attribute id { xsd:ID }?,
  attribute destdir { text }?,
  attribute genericjarsuffix { text }?,
  attribute classpath { text }?,
  attribute keepgenerated { boolean }?,
  attribute debug { boolean }?,
  attribute suffix { text }?,
  attribute iashome { text }?
support =
  element support {
    attlist.support,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.support &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
websphere =
  element websphere { attlist.websphere, (classpath | wasclasspath)* }
attlist.websphere &=
  attribute id { xsd:ID }?,
  attribute newcmp { boolean }?,
  attribute ejbdtd { text }?,
  attribute rmicoptions { text }?,
  attribute noinform { boolean }?,
  attribute rebuild { boolean }?,
  attribute suffix { text }?,
  attribute quiet { boolean }?,
  attribute dbschema { text }?,
  attribute destdir { text }?,
  attribute ejbdeploy { boolean }?,
  attribute use35 { boolean }?,
  attribute tempdir { text }?,
  attribute novalidate { boolean }?,
  attribute codegen { boolean }?,
  attribute dbvendor { text }?,
  attribute classpath { text }?,
  attribute wasclasspath { text }?,
  attribute oldcmp { boolean }?,
  attribute dbname { text }?,
  attribute keepgeneric { boolean }?,
  attribute trace { boolean }?,
  attribute nowarn { boolean }?,
  attribute genericjarsuffix { text }?
wasclasspath =
  element wasclasspath {
    attlist.wasclasspath,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.wasclasspath &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
p4change = element p4change { attlist.p4change, empty }
attlist.p4change &=
  attribute id { xsd:ID }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute failonerror { boolean }?,
  attribute description { text }?,
  attribute errormessage { text }?
ccmcreatetask = element ccmcreatetask { attlist.ccmcreatetask, empty }
attlist.ccmcreatetask &=
  attribute id { xsd:ID }?,
  attribute subsystem { text }?,
  attribute task { text }?,
  attribute platform { text }?,
  attribute resolver { text }?,
  attribute comment { text }?,
  attribute ccmaction { text }?,
  attribute ccmdir { text }?,
  attribute taskname { text }?,
  attribute release { text }?,
  attribute description { text }?
cvschangelog =
  element cvschangelog {
    attlist.cvschangelog, (fileset | user | module | commandline)*
  }
attlist.cvschangelog &=
  attribute id { xsd:ID }?,
  attribute cvsrsh { text }?,
  attribute endtag { text }?,
  attribute quiet { boolean }?,
  attribute passfile { text }?,
  attribute command { text }?,
  attribute end { text }?,
  attribute package { text }?,
  attribute start { text }?,
  attribute cvsroot { text }?,
  attribute remote { boolean }?,
  attribute reallyquiet { boolean }?,
  attribute starttag { text }?,
  attribute output { text }?,
  attribute port { text }?,
  attribute compressionlevel { text }?,
  attribute dest { text }?,
  attribute destfile { text }?,
  attribute usersfile { text }?,
  attribute dir { text }?,
  attribute noexec { boolean }?,
  attribute error { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute daysinpast { text }?,
  attribute append { boolean }?,
  attribute taskname { text }?,
  attribute date { text }?,
  attribute compression { boolean }?,
  attribute tag { text }?
user = element user { attlist.user, empty }
attlist.user &=
  attribute id { xsd:ID }?,
  attribute userid { text }?,
  attribute displayname { text }?
vssadd = element vssadd { attlist.vssadd, empty }
attlist.vssadd &=
  attribute id { xsd:ID }?,
  attribute ssdir { text }?,
  attribute recursive { boolean }?,
  attribute autoresponse { text }?,
  attribute vsspath { text }?,
  attribute comment { text }?,
  attribute serverpath { text }?,
  attribute writable { boolean }?,
  attribute login { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute localpath { text }?
dependset =
  element dependset {
    attlist.dependset,
    (patternset
     | exclude
     | \include
     | custom
     | sources
     | none
     | present
     | not
     | type
     | targetfileset
     | srcfileset
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | srcfilelist
     | date
     | excludesfile
     | targets
     | depth
     | and
     | targetfilelist)*
  }
attlist.dependset &=
  attribute id { xsd:ID }?,
  attribute verbose { boolean }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute taskname { text }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute includes { text }?
sources = element sources { attlist.sources, empty }
attlist.sources &=
  attribute id { xsd:ID }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?
targetfileset =
  element targetfileset {
    attlist.targetfileset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.targetfileset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
srcfileset =
  element srcfileset {
    attlist.srcfileset,
    (patternset
     | exclude
     | \include
     | custom
     | none
     | present
     | not
     | type
     | readable
     | writable
     | modified
     | or
     | contains
     | depend
     | different
     | size
     | majority
     | containsregexp
     | filename
     | selector
     | includesfile
     | date
     | excludesfile
     | and
     | depth)*
  }
attlist.srcfileset &=
  attribute id { xsd:ID }?,
  attribute refid { xsd:IDREF }?,
  attribute file { text }?,
  attribute dir { text }?,
  attribute defaultexcludes { boolean }?,
  attribute followsymlinks { boolean }?,
  attribute erroronmissingdir { boolean }?,
  attribute casesensitive { boolean }?,
  attribute description { text }?,
  attribute excludes { text }?,
  attribute includesfile { text }?,
  attribute excludesfile { text }?,
  attribute maxlevelsofsymlinks { text }?,
  attribute includes { text }?
srcfilelist = element srcfilelist { attlist.srcfilelist, file* }
attlist.srcfilelist &=
  attribute id { xsd:ID }?,
  attribute dir { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute files { text }?
targets =
  element targets {
    attlist.targets,
    (fileset
     | dirset
     | extdirs
     | existing
     | filelist
     | pathelement
     | path)*
  }
attlist.targets &=
  attribute id { xsd:ID }?,
  attribute location { text }?,
  attribute cache { boolean }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute path { text }?
targetfilelist =
  element targetfilelist { attlist.targetfilelist, file* }
attlist.targetfilelist &=
  attribute id { xsd:ID }?,
  attribute dir { text }?,
  attribute refid { xsd:IDREF }?,
  attribute description { text }?,
  attribute files { text }?
concat =
  element concat {
    attlist.concat,
    (text | filterchain | fileset | filelist | path | footer | header)*
  }
attlist.concat &=
  attribute id { xsd:ID }?,
  attribute force { boolean }?,
  attribute encoding { text }?,
  attribute append { boolean }?,
  attribute destfile { text }?,
  attribute forcereadonly { boolean }?,
  attribute binary { boolean }?,
  attribute overwrite { boolean }?,
  attribute eol {
    "asis" | "cr" | "lf" | "crlf" | "mac" | "unix" | "dos"
  }?,
  attribute outputencoding { text }?,
  attribute taskname { text }?,
  attribute ignoreempty { boolean }?,
  attribute fixlastline { boolean }?,
  attribute dest { text }?,
  attribute description { text }?
p4resolve = element p4resolve { attlist.p4resolve, empty }
attlist.p4resolve &=
  attribute id { xsd:ID }?,
  attribute forcetextmode { boolean }?,
  attribute port { text }?,
  attribute client { text }?,
  attribute inerror { boolean }?,
  attribute user { text }?,
  attribute cmdopts { text }?,
  attribute globalopts { text }?,
  attribute markersforall { boolean }?,
  attribute simulationmode { boolean }?,
  attribute view { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute failonerror { boolean }?,
  attribute errormessage { text }?,
  attribute resolvemode { text }?,
  attribute redoall { boolean }?
ccmklabel = element ccmklabel { attlist.ccmklabel, empty }
attlist.ccmklabel &=
  attribute id { xsd:ID }?,
  attribute recurse { boolean }?,
  attribute replace { boolean }?,
  attribute viewpath { text }?,
  attribute typename { text }?,
  attribute comment { text }?,
  attribute version { text }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute cleartooldir { text }?,
  attribute taskname { text }?,
  attribute vob { text }?,
  attribute description { text }?,
  attribute commentfile { text }?
local = element local { attlist.local, empty }
attlist.local &=
  attribute id { xsd:ID }?,
  attribute taskname { text }?,
  attribute name { text }?,
  attribute description { text }?
ccunlock = element ccunlock { attlist.ccunlock, empty }
attlist.ccunlock &=
  attribute id { xsd:ID }?,
  attribute objsel { text }?,
  attribute pname { text }?,
  attribute viewpath { text }?,
  attribute comment { text }?,
  attribute failonerr { boolean }?,
  attribute cleartooldir { text }?,
  attribute objselect { text }?,
  attribute taskname { text }?,
  attribute description { text }?
componentdef = element componentdef { attlist.componentdef, classpath* }
attlist.componentdef &=
  attribute id { xsd:ID }?,
  attribute name { text }?,
  attribute uri { text }?,
  attribute classpath { text }?,
  attribute file { text }?,
  attribute classname { text }?,
  attribute resource { text }?,
  attribute antlib { text }?,
  attribute adaptto { text }?,
  attribute onerror { "fail" | "report" | "ignore" | "failall" }?,
  attribute loaderref { xsd:IDREF }?,
  attribute classpathref { xsd:IDREF }?,
  attribute taskname { text }?,
  attribute adapter { text }?,
  attribute format { "properties" | "xml" }?,
  attribute description { text }?,
  attribute reverseloader { boolean }?
ccmkattr = element ccmkattr { attlist.ccmkattr, empty }
attlist.ccmkattr &=
  attribute id { xsd:ID }?,
  attribute recurse { boolean }?,
  attribute typevalue { text }?,
  attribute replace { boolean }?,
  attribute viewpath { text }?,
  attribute typename { text }?,
  attribute comment { text }?,
  attribute version { text }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute cleartooldir { text }?,
  attribute taskname { text }?,
  attribute description { text }?,
  attribute commentfile { text }?
cccheckout = element cccheckout { attlist.cccheckout, empty }
attlist.cccheckout &=
  attribute id { xsd:ID }?,
  attribute reserved { boolean }?,
  attribute viewpath { text }?,
  attribute out { text }?,
  attribute notco { boolean }?,
  attribute comment { text }?,
  attribute nodata { boolean }?,
  attribute version { boolean }?,
  attribute nowarn { boolean }?,
  attribute failonerr { boolean }?,
  attribute objselect { text }?,
  attribute cleartooldir { text }?,
  attribute taskname { text }?,
  attribute branch { text }?,
  attribute description { text }?,
  attribute commentfile { text }?
start = project
