#!/usr/bin/env ruby

=begin
Git Elpa
========

This module is used to simplify updating Emacs ELPA packages.

In a nutshell, this script will list names of packages which have been
updated/added, or commit them all (each as separate commits), or
commit a single package update (or addition) by it's package name.

Abstract
========

In this Emacs config, unlike most, I maintain a repository history of
the ELPA packages I install. Usually (99% of the time over many years
so far) I have no issues with this at all.  Of course, hypothetically,
it's quite possible that any feature of any package could be broken at
any time.

In case a breakage occurs, it's possible to roll back to a previous
version of that package, and it's easy to do when we can identify the
package. We can simply cherry-pick it from a previous commit, or just
grab it from it's canonical source.

However, if the breakage manifests as a side-effect, identifying
the problem package is much harder.

To this end, I wrote this script to make each package have it's own
commit history, (starting today!)

Usage:
======

    git-elpa --list

List all updated packages, not yet committed.

    git-elpa --commit=package-name

Commit the package update (and old version removal). The following
automatic commit message pattern will be used:

"[package-name upgraded] to NEW_VERSION from OLD_VERSION"

    git-elpa --all

Commit all updated packages (as individual commits)

=end

require 'shellwords'

class GitElpa

  EMACS_D = File.join(Dir.home, ".emacs.d")

  def initialize
  end

  def updatable_files_from_git_status
    %x[git status -s | grep -E -o '^( D | A |[?]{2} )elpa/.*?(\.signed|/)' | uniq].split("\n")
  end

  def updated_packages
    package_name = Regexp.new("^(.*)-.*?$")
    updatable = updatable_files_from_git_status
                .map{|name| name[8..name.length] }
    updated_names = updatable.map {|u| package_name.match(u)[1] if package_name.match(u) }.uniq

    if updated_names.length > 0
      updated_names
    else
      abort "There are updated packages / no commits required"
    end
  end

  def commit_all_packages
    updated_packages.each do |p|
      commit_package p
    end
  end

  def commit_package(package, do_commit = true)
    @package = package
    @rx = Regexp.new("(^elpa/)(#{Regexp.quote(@package)})-([^-]*?)(\.signed|/.*)")
    @old = old_versions
    @ver = new_version
    if do_commit
      commit
    end
  end

  def commit_message
    return "[Removing #{@package} version: #{@old.join(',')}]"                                  if @ver.nil? && @old.length == 1
    return "[Removing #{@package} versions: #{@old.join(',')}]"                                 if @ver.nil? && @old.length > 1
    return "[Updating #{@package} version: #{@ver}][removing old versions: #{@old.join(',')}]"  if @ver && @old.length > 1
    return "[Updating #{@package} version: #{@ver}][removing old version: #{@old.first}]"       if @ver && @old.length == 1
    return "[Adding #{@package} version: #{@ver}]"                                              if @ver && @old.length == 0
  end

  def add_to_index
    new_version_files.each do |file|
      %x[zsh -c "git add \"#{file.shellescape}\""]
    end unless @ver.nil?
    old_version_files.each do |file|
      %x[zsh -c "git rm -rf \"#{file.shellescape}\""]
    end if @old.length > 0
  end

  def commit(message = commit_message)
    add_to_index
    puts message
    %x[git commit -m "#{message}"]
  end

  def new_version
    versions = new_version_files.map{|f| @rx.match(f)[3] }.uniq
    if versions.length > 1
      abort "There are more than one new versions of #{@package}"
    end
    versions.first
  end

  def old_versions
    old_version_files.map{|f| @rx.match(f)[3] }.uniq
  end

  def cleanup_version_file_names list
    list.map{|f| f.gsub(/^.{3}elpa\//, '')}
      .select{|f| f != "" }
  end

  def filter_version_files status_rx
    cleanup_version_file_names updatable_files_from_git_status
                                .select{|file| status_rx.match file }
                                .map{|file| file.gsub status_rx, ''}
                                .select{|f| @rx.match(f) }
  end

  def new_version_files
    status_rx = /^( A |[?]{2} )/
    filter_version_files status_rx
  end

  def old_version_files
    status_rx = /^( D )/
    filter_version_files status_rx
  end

  def commit_archives
    %x[git add elpa/archives]
    %x[git commit -m "Updating elpa archives"]
  end
end

require 'optparse'

option_parser = OptionParser.new do |opts|
  elpa = GitElpa.new()
  opts.banner = %Q^
Emacs ELPA package commit tool

This tool is designed to assist the storage of your installed ELPA packages.
It will commit each package separately.

Usage: git-elpa [options]
^

  opts.on "-l", "--list", "List updated packages" do
    puts "Listing updated ELPA packages...(to be committed)", ""
    puts elpa.updated_packages
    exit 0
  end

  opts.on "-cPACKAGE", "--commit=PACKAGE", "Commit a new/updated elpa package" do |package|
    elpa.commit_package package
    exit 0
  end

  opts.on "-A", "--all", "Commit all updated elpa packages (as individual commits)" do
    puts <<-EOD.gsub(/^ */,'')
        Commit all updated packages

        Current commit (for reset):
        #{`git log --pretty=oneline -1`}
    EOD
    elpa.commit_all_packages
    exit 0
  end

  opts.on "-e", "--elpa-archive", "Commit updated elpa/melpa archive index" do
    elpa.commit_archives
    exit 0
  end
end

option_parser.parse!

puts option_parser
